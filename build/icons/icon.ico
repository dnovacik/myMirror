 $b] = makeTypesMatch($a, $b);\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n  return ENGINE.runKernel(backend => backend.notEqual($a, $b), {$a, $b}) as T;\n}\n\n/**\n * Strict version of `tf.notEqual` that forces `a` and `b` to be of the same\n * shape.\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same shape and dtype as\n *     `a`.\n */\nfunction notEqualStrict_<T extends Tensor>(\n    a: T|TensorLike, b: T|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'notEqualStrict');\n  const $b = convertToTensor(b, 'b', 'notEqualStrict');\n  assertShapesMatch($a.shape, $b.shape, 'Error in notEqualStrict: ');\n  return $a.notEqual($b);\n}\n\n/**\n * Returns the truth value of (a < b) element-wise. Supports broadcasting.\n *\n * We also expose `tf.lessStrict` which has the same signature as this op and\n * asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.less(b).print();\n * ```\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Logical'} */\nfunction less_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'less');\n  let $b = convertToTensor(b, 'b', 'less');\n  [$a, $b] = makeTypesMatch($a, $b);\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  return ENGINE.runKernel(backend => backend.less($a, $b), {$a, $b}) as T;\n}\n\n/**\n * Strict version of `tf.less` that forces `a` and `b` to be of the same\n * shape.\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same shape and dtype as\n *     `a`.\n */\nfunction lessStrict_<T extends Tensor>(a: T|TensorLike, b: T|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'lessStrict');\n  const $b = convertToTensor(b, 'b', 'lessStrict');\n  assertShapesMatch($a.shape, $b.shape, 'Error in lessStrict: ');\n  return $a.less($b);\n}\n\n/**\n * Returns the truth value of (a == b) element-wise. Supports broadcasting.\n *\n * We also expose `tf.equalStrict` which has the same signature as this op\n * and asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.equal(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Logical'} */\nfunction equal_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'equal');\n  let $b = convertToTensor(b, 'b', 'equal');\n  [$a, $b] = makeTypesMatch($a, $b);\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  return ENGINE.runKernel(backend => backend.equal($a, $b), {$a, $b}) as T;\n}\n\nfunction equalStrict_<T extends Tensor>(a: T|TensorLike, b: T|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'equalStrict');\n  const $b = convertToTensor(b, 'b', 'equalStrict');\n  assertShapesMatch($a.shape, $b.shape, 'Error in equalStrict: ');\n  return $a.equal($b);\n}\n\n/**\n * Returns the truth value of (a <= b) element-wise. Supports broadcasting.\n *\n * We also expose `tf.lessEqualStrict` which has the same signature as this op\n * and asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.lessEqual(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Logical'} */\nfunction lessEqual_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'lessEqual');\n  let $b = convertToTensor(b, 'b', 'lessEqual');\n  [$a, $b] = makeTypesMatch($a, $b);\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  return ENGINE.runKernel(backend => backend.lessEqual($a, $b), {$a, $b}) as T;\n}\n\nfunction lessEqualStrict_<T extends Tensor>(\n    a: T|TensorLike, b: T|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'lessEqualStrict');\n  const $b = convertToTensor(b, 'b', 'lessEqualStrict');\n  assertShapesMatch($a.shape, $b.shape, 'Error in lessEqualStrict: ');\n  return $a.lessEqual($b);\n}\n\n/**\n * Returns the truth value of (a > b) element-wise. Supports broadcasting.\n *\n * We also expose `tf.greaterStrict` which has the same signature as this\n * op and asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.greater(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Logical'} */\nfunction greater_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'greater');\n  let $b = convertToTensor(b, 'b', 'greater');\n  [$a, $b] = makeTypesMatch($a, $b);\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  return ENGINE.runKernel(backend => backend.greater($a, $b), {$a, $b}) as T;\n}\n\nfunction greaterStrict_<T extends Tensor>(a: T|TensorLike, b: T|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'greaterStrict');\n  const $b = convertToTensor(b, 'b', 'greaterStrict');\n  assertShapesMatch($a.shape, $b.shape, 'Error in greaterStrict: ');\n  return $a.greater($b);\n}\n\n/**\n * Returns the truth value of (a >= b) element-wise. Supports broadcasting.\n *\n * We also expose `tf.greaterEqualStrict` which has the same signature as this\n * op and asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.greaterEqual(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Logical'} */\nfunction greaterEqual_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'greaterEqual');\n  let $b = convertToTensor(b, 'b', 'greaterEqual');\n  [$a, $b] = makeTypesMatch($a, $b);\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const grad = (dy: T, saved: Tensor[]) => {\n    const [$a, $b] = saved;\n    return {$a: () => zerosLike($a), $b: () => zerosLike($b)};\n  };\n  return ENGINE.runKernel((backend, save) => {\n    const res = backend.greaterEqual($a, $b);\n    save([$a, $b]);\n    return res;\n  }, {$a, $b}, grad) as T;\n}\n\nfunction greaterEqualStrict_<T extends Tensor>(\n    a: T|TensorLike, b: T|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'greaterEqualStrict');\n  const $b = convertToTensor(b, 'b', 'greaterEqualStrict');\n  assertShapesMatch($a.shape, $b.shape, 'Error in greaterEqualStrict: ');\n  return $a.greaterEqual($b);\n}\n\nexport const equal = op({equal_});\nexport const equalStrict = op({equalStrict_});\nexport const greater = op({greater_});\nexport const greaterEqual = op({greaterEqual_});\nexport const greaterEqualStrict = op({greaterEqualStrict_});\nexport const greaterStrict = op({greaterStrict_});\nexport const less = op({less_});\nexport const lessEqual = op({lessEqual_});\nexport const lessEqualStrict = op({lessEqualStrict_});\nexport const lessStrict = op({lessStrict_});\nexport const notEqual = op({notEqual_});\nexport const notEqualStrict = op({notEqualStrict_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Tensor1D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert, isInt, parseAxisParam} from '../util';\nimport {expandDims} from './array_ops';\nimport {getUndoAxesPermutation} from './axis_util';\nimport {maximum} from './binary_ops';\nimport {greaterEqual} from './compare';\nimport {logicalAnd, where} from './logical_ops';\nimport {op} from './operation';\nimport {collectGatherOpShapeInfo} from './segment_util';\nimport {ones, scalar, zerosLike} from './tensor_ops';\n\n/**\n * Computes the sum along segments of a `tf.Tensor`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');\n * const numSegments = 3;\n *\n * x.unsortedSegmentSum(segmentIds, numSegments).print()\n * //or tf.unsortedSegmentSum(x, segmentIds, numSegments)\n * ```\n * @param x The `tf.Tensor` that will be summed along its segments.\n * @param segmentIds A `tf.Tensor1D` whose rank is equal to the rank of `x`'s\n * dimension along the `axis`.  Maps each element of `x` to a segment.\n * @param numSegments The number of distinct `segmentIds`.\n */\n/** @doc {heading: 'Operations', subheading: 'Segment'} */\nfunction unsortedSegmentSum_<T extends Tensor>(\n    x: T|TensorLike, segmentIds: Tensor1D|TensorLike, numSegments: number): T {\n  const $x = convertToTensor(x, 'x', 'unsortedSegmentSum');\n  const $segmentIds =\n      convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');\n  assert(isInt(numSegments), () => 'numSegments must be of dtype int');\n\n  const gradFunc = (dy: T, saved: Tensor[]) => {\n    const [$segmentIds] = saved;\n    const derX = () => {\n      return gatherDropNegatives(dy, $segmentIds as Tensor1D);\n    };\n    return {$x: derX};\n  };\n  return ENGINE.runKernel((backend, save) => {\n    const res = backend.unsortedSegmentSum($x, $segmentIds, numSegments);\n    save([$segmentIds]);\n    return res;\n  }, {$x}, gradFunc) as T;\n}\n\n/**\n * Gather slices from tensor `x`'s axis `axis` according to `indices`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const indices = tf.tensor1d([1, 3, 3], 'int32');\n *\n * x.gather(indices).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const indices = tf.tensor1d([1, 1, 0], 'int32');\n *\n * x.gather(indices).print();\n * ```\n * @param x The input tensor whose slices to be gathered.\n * @param indices The indices of the values to extract.\n * @param axis The axis over which to select values. Defaults to 0.\n */\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\nfunction gather_<T extends Tensor>(\n    x: T|TensorLike, indices: Tensor|TensorLike, axis = 0): T {\n  const $x = convertToTensor(x, 'x', 'gather');\n  const $indices = convertToTensor(indices, 'indices', 'gather', 'int32');\n  axis = parseAxisParam(axis, $x.shape)[0];\n  const shapeInfo = collectGatherOpShapeInfo($x, $indices, axis);\n\n  const grad = (dy: T, saved: Tensor[]) => {\n    const [$indices] = saved;\n    const derX = () => {\n      const paramsShape = $x.shape;\n      const indicesSize = $indices.size;\n\n      const outerShape = paramsShape.slice(0, axis);\n      const outerDims = outerShape.length;\n      const innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);\n      const innerDims = innerShape.length;\n\n      const outerAxesIndices = arrayRange(0, outerDims);\n      const innerAxesIndices =\n          arrayRange(outerDims + 1, outerDims + 1 + innerDims);\n\n      const valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);\n\n      const values = dy.reshape(valuesShape);\n      const reshapedIndices = $indices.reshape([indicesSize]);\n\n      const transposeDims =\n          arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);\n      const valuesTranspose = values.transpose(transposeDims);\n      let paramsGrad = unsortedSegmentSum(\n          valuesTranspose, reshapedIndices as Tensor1D, $x.shape[axis]);\n\n      const invertTransposeDims = getUndoAxesPermutation(transposeDims);\n      paramsGrad = paramsGrad.transpose(invertTransposeDims);\n\n      return paramsGrad as T;\n    };\n    return {$x: derX};\n  };\n  return (ENGINE.runKernel((backend, save) => {\n           const res = backend.gather($x, $indices.flatten(), axis);\n           save([$indices]);\n           return res;\n         }, {$x}, grad)).reshape(shapeInfo.outputShape) as T;\n}\n\nfunction arrayRange(start: number, stop: number): number[] {\n  const result = [];\n  for (let i = start; i < stop; ++i) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction arrayConcat(arrays: number[][]): number[] {\n  const result = [];\n  for (let i = 0; i < arrays.length; ++i) {\n    for (let j = 0; j < arrays[i].length; ++j) {\n      result.push(arrays[i][j]);\n    }\n  }\n  return result;\n}\n\nfunction gatherDropNegatives<T extends Tensor>(x: T, indices: Tensor1D) {\n  // Helper function for unsorted segment ops. Gathers params for\n  // positive segment ids and gathers 0 for inputs with negative segment id.\n  // Mirrors _GatherDropNegatives from tensorflow/python/ops/math_grad.py\n  const zeroClippedIndices = maximum(indices, zerosLike(indices));\n  const gathered = gather(x, zeroClippedIndices as Tensor1D);\n  let isPositive = greaterEqual(indices, scalar(0, 'int32'));\n  const numIters = gathered.rank - isPositive.rank;\n  for (let i = 0; i < numIters; ++i) {\n    isPositive = expandDims(isPositive, i + 1);\n  }\n  isPositive = logicalAnd(isPositive, ones(gathered.shape, 'bool'));\n  const zeroSlice = zerosLike(gathered);\n  return where(isPositive, gathered, zeroSlice);\n}\n\nexport const gather = op({gather_});\nexport const unsortedSegmentSum = op({unsortedSegmentSum_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {whereAsync} from './logical_ops';\nimport {gather} from './segment_ops';\n\n/**\n * Apply boolean mask to tensor.\n *\n * ```js\n * const tensor = tf.tensor2d([1, 2, 3, 4, 5, 6], [3, 2]);\n * const mask = tf.tensor1d([1, 0, 1], 'bool');\n * const result = await tf.booleanMaskAsync(tensor, mask);\n * result.print();\n * ```\n *\n * @param N-D tensor.\n * @param mask K-D boolean tensor, K <= N and K must be known statically.\n * @param axis A 0-D int Tensor representing the axis in tensor to mask from.\n *     By default, axis is 0 which will mask from the first dimension.\n *     Otherwise K + axis <= N.\n */\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\nasync function booleanMaskAsync_(\n    tensor: Tensor|TensorLike, mask: Tensor|TensorLike,\n    axis?: number): Promise<Tensor> {\n  const $tensor = convertToTensor(tensor, 'tensor', 'boolMask');\n  const $mask = convertToTensor(mask, 'mask', 'boolMask', 'bool');\n\n  const axisFrom = axis == null ? 0 : axis;\n  const maskDim = $mask.rank;\n  const tensorShape = $tensor.shape;\n\n  util.assert(maskDim > 0, () => 'mask cannot be scalar');\n  util.assertShapesMatch(\n      tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape,\n      `mask's shape must match the first K dimensions of tensor's shape,`);\n\n  let leadingSize = 1;\n  for (let i = axisFrom; i < axisFrom + maskDim; i++) {\n    leadingSize *= tensorShape[i];\n  }\n  const targetTensorShape =\n      tensorShape.slice(0, axisFrom)\n          .concat([leadingSize], tensorShape.slice(axisFrom + maskDim));\n  const reshapedTensor = $tensor.reshape(targetTensorShape);\n  const reshapedMask = $mask.reshape([-1]);\n  const positivePositions = await whereAsync(reshapedMask);\n  const indices = positivePositions.squeeze([1]);\n\n  const res = gather(reshapedTensor, indices, axisFrom);\n\n  // Ensure no memory leak.\n  if (tensor !== $tensor) {\n    $tensor.dispose();\n  }\n  if (mask !== $mask) {\n    $mask.dispose();\n  }\n  indices.dispose();\n  reshapedTensor.dispose();\n  reshapedMask.dispose();\n  positivePositions.dispose();\n\n  return res;\n}\n\nexport const booleanMaskAsync = booleanMaskAsync_;\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Tensor2D, Tensor3D, Tensor4D, Tensor5D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\n\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction conv1d_<T extends Tensor2D|Tensor3D>(\n    x: T|TensorLike, filter: Tensor3D|TensorLike, stride: number,\n    pad: 'valid'|'same'|number, dataFormat: 'NWC'|'NCW' = 'NWC', dilation = 1,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'conv1d');\n  const $filter = convertToTensor(filter, 'filter', 'conv1d');\n\n  let x3D = $x as Tensor3D;\n  let reshapedTo3D = false;\n  if ($x.rank === 2) {\n    reshapedTo3D = true;\n    x3D = $x.as3D(1, $x.shape[0], $x.shape[1]);\n  }\n\n  util.assert(\n      x3D.rank === 3,\n      () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n  util.assert(\n      $filter.rank === 3,\n      () => `Error in conv1d: filter must be rank 3, but got rank ` +\n          `${$filter.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv1d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  util.assert(\n      x3D.shape[2] === $filter.shape[1],\n      () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` +\n          `input depth for filter ${$filter.shape[1]}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(stride, dilation),\n      () => 'Error in conv1D: Either stride or dilation must be 1. ' +\n          `Got stride ${stride} and dilation '${dilation}'`);\n  util.assert(\n      dataFormat === 'NWC',\n      () => `Error in conv1d: got dataFormat of ${\n          dataFormat} but only NWC is currently supported.`);\n\n  const filter4D =\n      $filter.as4D(1, $filter.shape[0], $filter.shape[1], $filter.shape[2]);\n  const input4D = x3D.as4D(x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]);\n  const strides: [number, number] = [1, stride];\n  const dilations: [number, number] = [1, dilation];\n\n  const conv2dDataFormat = 'NHWC';\n\n  const res = conv2d(\n      input4D, filter4D, strides, pad, conv2dDataFormat, dilations,\n      dimRoundingMode);\n\n  if (reshapedTo3D) {\n    return res.as2D(res.shape[2], res.shape[3]) as T;\n  }\n  return res.as3D(res.shape[0], res.shape[2], res.shape[3]) as T;\n}\n\n/**\n * Computes a 2D convolution over the input x.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction conv2d_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filter: Tensor4D|TensorLike,\n    strides: [number, number]|number, pad: 'valid'|'same'|number,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dilations: [number, number]|number = [1, 1],\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'conv2d');\n  const $filter = convertToTensor(filter, 'filter', 'conv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);\n  util.assert(\n      $filter.rank === 4,\n      () => `Error in conv2d: filter must be rank 4, but got rank ` +\n          `${$filter.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv2d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n  const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n  util.assert(\n      inDepth === $filter.shape[2],\n      () => `Error in conv2d: depth of input (${inDepth}) must match ` +\n          `input depth for filter ${$filter.shape[2]}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in conv2D: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = conv_util.computeConv2DInfo(\n      x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode, false,\n      $dataFormat);\n\n  const grad = (dy: Tensor4D, saved: Tensor[]) => {\n    const [$filter, x4D] = saved as [Tensor4D, Tensor4D];\n    util.assert(\n        conv_util.tupleValuesAreOne(dilations),\n        () => 'Error in gradient of conv2D: dilation rates greater than 1 ' +\n            `are not yet supported in gradients. Got dilations '${dilations}'`);\n\n    return {\n      x: () =>\n          conv2dDerInput_(x4D.shape, dy, $filter, strides, pad, dataFormat),\n      $filter: () =>\n          conv2dDerFilter_(x4D, dy, $filter.shape, strides, pad, dataFormat)\n    };\n  };\n\n  const res = ENGINE.runKernel((backend, save) => {\n    const res = backend.conv2d(x4D, $filter, convInfo);\n    save([$filter, x4D]);\n\n    return res;\n  }, {x: x4D, $filter}, grad);\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the derivative of the input of a 2D convolution.\n *\n * @param xShape The shape of the input: [batch, height, width, inDepth].\n * If length of 3, batch of 1 is assumed.\n * @param dy The derivative of the output, of rank 4 or rank 3 of shape\n *   `[batch, outHeight, outWidth, outDepth]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm used:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\nfunction conv2dDerInput_<T extends Tensor3D|Tensor4D>(\n    xShape: [number, number, number, number]|[number, number, number], dy: T,\n    filter: Tensor4D, strides: [number, number]|number,\n    pad: 'valid'|'same'|number, dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  util.assert(\n      xShape.length === dy.rank,\n      () => `Length of inShape ` +\n          `(${xShape.length}) and rank of dy (${dy.rank}) must match`);\n\n  let xShape4D = xShape as [number, number, number, number];\n  let dy4D = dy as Tensor4D;\n  let reshapedTo4D = false;\n  if (dy.rank === 3) {\n    reshapedTo4D = true;\n    dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n    xShape4D = [1, xShape[0], xShape[1], xShape[2]];\n  }\n\n  util.assert(\n      xShape4D.length === 4,\n      () =>\n          `Error in conv2dDerInput: inShape must be length 4, but got length ` +\n          `${xShape4D.length}.`);\n  util.assert(\n      dy4D.rank === 4,\n      () => `Error in conv2dDerInput: dy must be rank 4, but got ` +\n          `rank ${dy4D.rank}`);\n  util.assert(\n      filter.rank === 4,\n      () => `Error in conv2dDerInput: filter must be rank 4, but got ` +\n          `rank ${filter.rank}`);\n  const inDepth = dataFormat === 'NHWC' ? xShape4D[3] : xShape4D[1];\n  const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n  util.assert(\n      inDepth === filter.shape[2],\n      () => `Error in conv2dDerInput: depth of input (${inDepth}) must ` +\n          `match input depth for filter ${filter.shape[2]}.`);\n  util.assert(\n      outDepth === filter.shape[3],\n      () => `Error in conv2dDerInput: depth of output (${outDepth}) must ` +\n          `match output depth for filter ${filter.shape[3]}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv2dDerInput: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const dilations = 1;\n\n  const grad = (ddx: Tensor4D, saved: Tensor[]) => {\n    const [filter, dy4D] = saved;\n    return {\n      dy4D: () => conv2d(\n          ddx, filter as Tensor4D, strides, pad, dataFormat, dilations,\n          dimRoundingMode),\n      filter: () => conv2dDerFilter(\n          ddx, dy4D as Tensor4D, (filter as Tensor4D).shape, strides, pad,\n          dataFormat, dimRoundingMode)\n    };\n  };\n\n  const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = conv_util.computeConv2DInfo(\n      xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode, false,\n      $dataFormat);\n  const res = ENGINE.runKernel((backend, save) => {\n    const res = backend.conv2dDerInput(dy4D, filter, convInfo);\n    save([filter, dy4D]);\n    return res;\n  }, {dy4D, filter}, grad);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the derivative of the filter of a 2D convolution.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\n * @param dy The dy image, of rank 4 or rank 3, of shape\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\n * @param filterShape The shape of the filter, length 4,\n *     [filterHeight, filterWidth, inDepth, outDepth].\n * @param strides The strides of the convolution: [strideHeight,\n * strideWidth].\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction conv2dDerFilter_<T extends Tensor3D|Tensor4D>(\n    x: T, dy: T, filterShape: [number, number, number, number],\n    strides: [number, number]|number, pad: 'valid'|'same'|number,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dimRoundingMode?: 'floor'|'round'|'ceil'): Tensor4D {\n  let x4D = x as Tensor4D;\n  if (x.rank === 3) {\n    x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n  }\n  let dy4D = dy as Tensor4D;\n  if (dy4D.rank === 3) {\n    dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` +\n          `${x4D.shape}.`);\n  util.assert(\n      dy4D.rank === 4,\n      () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` +\n          `${dy4D.shape}.`);\n  util.assert(\n      filterShape.length === 4,\n      () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` +\n          `${filterShape}.`);\n  const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n  const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n  util.assert(\n      inDepth === filterShape[2],\n      () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` +\n          `match input depth in filter (${filterShape[2]}.`);\n  util.assert(\n      outDepth === filterShape[3],\n      () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` +\n          `match output depth for filter (${filterShape[3]}).`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv2dDerFilter: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const dilations = 1;\n  const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = conv_util.computeConv2DInfo(\n      x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode, false,\n      $dataFormat);\n  return ENGINE.runKernel(\n      backend => backend.conv2dDerFilter(x4D, dy4D, convInfo), {x4D, dy4D});\n}\n\n/**\n * Computes the transposed 2D convolution of an image, also known as a\n * deconvolution.\n *\n * @param x The input image, of rank 4 or rank 3, of shape\n *   `[batch, height, width, inDepth]`. If rank 3, batch of 1 is assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, outDepth, inDepth]`.\n *     `inDepth` must match `inDepth` in `x`.\n * @param outputShape Output shape, of rank 4 or rank 3:\n *     `[batch, height, width, outDepth]`. If rank 3, batch of 1 is assumed.\n * @param strides The strides of the original convolution:\n *     `[strideHeight, strideWidth]`.\n * @param pad  The type of padding algorithm used in the non-transpose version\n *    of the op.\n * @param dimRoundingMode The rounding mode used when computing output\n *    dimensions if pad is a number. If none is provided, it will not round\n *    and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction conv2dTranspose_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filter: Tensor4D|TensorLike,\n    outputShape: [number, number, number, number]|[number, number, number],\n    strides: [number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'conv2dTranspose');\n  const $filter = convertToTensor(filter, 'filter', 'conv2dTranspose');\n\n  return conv2dDerInput_(\n      outputShape, $x, $filter, strides, pad, 'NHWC', dimRoundingMode);\n}\n\n/**\n * Depthwise 2D convolution.\n *\n * Given a 4D `input` array and a `filter` array of shape\n * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing\n * `inChannels` convolutional filters of depth 1, this op applies a\n * different filter to each input channel (expanding from 1 channel to\n * `channelMultiplier` channels for each), then concatenates the results\n * together. The output has `inChannels * channelMultiplier` channels.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)\n * for more details.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction depthwiseConv2d_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filter: Tensor4D|TensorLike,\n    strides: [number, number]|number, pad: 'valid'|'same'|number,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dilations: [number, number]|number = [1, 1],\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'depthwiseConv2d');\n  const $filter = convertToTensor(filter, 'filter', 'depthwiseConv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in depthwiseConv2d: input must be rank 4, but got ` +\n          `rank ${x4D.rank}.`);\n  util.assert(\n      $filter.rank === 4,\n      () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ` +\n          `${$filter.rank}.`);\n  util.assert(\n      x4D.shape[3] === $filter.shape[2],\n      () => `Error in depthwiseConv2d: number of input channels ` +\n          `(${x4D.shape[3]}) must match the inChannels dimension in ` +\n          `filter ${$filter.shape[2]}.`);\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () =>\n          'Error in depthwiseConv2d: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in depthwiseConv2d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computeConv2DInfo(\n      x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode,\n      true /* depthwise */);\n\n  const grad = (dy: Tensor4D, saved: Tensor[]) => {\n    util.assert(\n        conv_util.tupleValuesAreOne(dilations),\n        () => 'Error in gradient of depthwiseConv2d: dilation rates ' +\n            `greater than 1 are not yet supported. Got dilations ` +\n            `'${dilations}'`);\n    const [x4D, $filter] = saved;\n    return {\n      x: () => depthwiseConv2dDerInput(\n          (x4D as Tensor4D).shape, dy, $filter as Tensor4D, convInfo),\n      $filter: () => depthwiseConv2dDerFilter(\n          x4D as Tensor4D, dy, ($filter as Tensor4D).shape, convInfo),\n    };\n  };\n\n  const res = ENGINE.runKernel((backend, save) => {\n    const res = backend.depthwiseConv2D(x4D, $filter, convInfo);\n    save([x4D, $filter]);\n    return res;\n  }, {x: x4D, $filter}, grad);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * 2-D convolution with separable filters.\n *\n * Performs a depthwise convolution that acts separately on channels followed\n * by a pointwise convolution that mixes channels. Note that this is\n * separability between dimensions [1, 2] and 3, not spatial separability\n * between dimensions 1 and 2.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)\n * for more details.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param depthwiseFilter The depthwise filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is\n *     the filter used in the first step.\n * @param pointwiseFilter The pointwise filter tensor, rank 4, of shape\n *     `[1, 1, inChannels * channelMultiplier, outChannels]`. This is\n *     the filter used in the second step.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction separableConv2d_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, depthwiseFilter: Tensor4D|TensorLike,\n    pointwiseFilter: Tensor4D|TensorLike, strides: [number, number]|number,\n    pad: 'valid'|'same', dilation: [number, number]|number = [1, 1],\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC'): T {\n  const $x = convertToTensor(x, 'x', 'separableConv2d');\n  const $depthwiseFilter =\n      convertToTensor(depthwiseFilter, 'depthwiseFilter', 'separableConv2d');\n  const $pointwiseFilter =\n      convertToTensor(pointwiseFilter, 'pointwiseFilter', 'separableConv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n\n  if (dataFormat === 'NCHW') {\n    throw new Error(\n        'separableConv2d currently does not support dataFormat NCHW; only ' +\n        'NHWC is supported');\n  }\n\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in separableConv2d: input must be rank 4, but got ` +\n          `rank ${x4D.rank}.`);\n  util.assert(\n      $depthwiseFilter.rank === 4,\n      () => `Error in separableConv2d: depthwise filter must be rank 4, but ` +\n          `got rank ${$depthwiseFilter.rank}.`);\n  util.assert(\n      $pointwiseFilter.rank === 4,\n      () => `Error in separableConv2d: pointwise filter must be rank 4, but ` +\n          `got rank ${$depthwiseFilter.rank}.`);\n  util.assert(\n      $pointwiseFilter.shape[0] === 1,\n      () =>\n          `Error in separableConv2d: the first dimension of pointwise filter ` +\n          ` must be 1, but got ${$pointwiseFilter.shape[0]}.`);\n  util.assert(\n      $pointwiseFilter.shape[1] === 1,\n      () => `Error in separableConv2d: the second dimension of pointwise ` +\n          `filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);\n\n  const inChannels = $depthwiseFilter.shape[2];\n  const channelMultiplier = $depthwiseFilter.shape[3];\n  util.assert(\n      $pointwiseFilter.shape[2] === inChannels * channelMultiplier,\n      () =>\n          `Error in separableConv2d: the third dimension of pointwise filter ` +\n          `must be ${inChannels * channelMultiplier}, ` +\n          `but got ${$pointwiseFilter.shape[2]}.`);\n\n  const depthwise = depthwiseConv2d(\n      x4D, $depthwiseFilter, strides, pad, dataFormat, dilation);\n  const pointwiseStride = 1;\n  const res =\n      conv2d(depthwise, $pointwiseFilter, pointwiseStride, 'valid', dataFormat);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\nfunction parseTupleParam(\n    param: number|[number, number]|[number, number, number]):\n    [number, number, number] {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n  return param;\n}\n\nfunction tupleValuesAreOne(\n    param: number|[number, number]|[number, number, number]): boolean {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\n\nfunction eitherStridesOrDilationsAreOne(\n    strides: number|[number, number]|[number, number, number],\n    dilations: number|[number, number]|[number, number, number]): boolean {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n\nfunction depthwiseConv2dDerInput<T extends Tensor3D|Tensor4D>(\n    xShape: [number, number, number, number]|[number, number, number], dy: T,\n    filter: Tensor4D, convInfo: conv_util.Conv2DInfo): T {\n  let dy4D = dy as Tensor4D;\n  let reshapedTo4D = false;\n  if (dy.rank === 3) {\n    reshapedTo4D = true;\n    dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n  }\n  const res = ENGINE.runKernel(\n      backend => backend.depthwiseConv2DDerInput(dy4D, filter, convInfo),\n      {dy4D});\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\nfunction depthwiseConv2dDerFilter<T extends Tensor3D|Tensor4D>(\n    x: T, dy: T, filterShape: [number, number, number, number],\n    convInfo: conv_util.Conv2DInfo): Tensor4D {\n  let x4D = x as Tensor4D;\n  if (x.rank === 3) {\n    x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n  }\n  let dy4D = dy as Tensor4D;\n  if (dy4D.rank === 3) {\n    dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n  }\n  return ENGINE.runKernel(\n      backend => backend.depthwiseConv2DDerFilter(x4D, dy4D, convInfo),\n      {x4D, dy4D});\n}\n\n/**\n * Computes a 3D convolution over the input x.\n *\n * @param x The input tensor, of rank 5 or rank 4, of shape\n *     `[batch, depth, height, width, channels]`. If rank 4,\n * batch of 1 is assumed.\n * @param filter The filter, rank 5, of shape\n *     `[filterDepth, filterHeight, filterWidth, inChannels, outChannels]`.\n *      inChannels must match between input and filter.\n * @param strides The strides of the convolution: `[strideDepth, strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat: An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates: `[dilationDepth, dilationHeight,\n *     dilationWidth]` in which we sample input values across the height\n *     and width dimensions in atrous convolution. Defaults to `[1, 1, 1]`.\n *     If `dilations` is a single number, then\n *     `dilationDepth == dilationHeight == dilationWidth`. If it is greater\n *     than 1, then all values of `strides` must be 1.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction conv3d_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike, filter: Tensor5D|TensorLike,\n    strides: [number, number, number]|number, pad: 'valid'|'same',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC',\n    dilations: [number, number, number]|number = [1, 1, 1]): T {\n  const $x = convertToTensor(x, 'x', 'conv3d');\n  const $filter = convertToTensor(filter, 'filter', 'conv3d');\n\n  let x5D = $x as Tensor5D;\n  let reshapedTo5D = false;\n\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = $x.as5D(1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]);\n  }\n  util.assert(\n      x5D.rank === 5,\n      () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);\n  util.assert(\n      $filter.rank === 5,\n      () => `Error in conv3d: filter must be rank 5, but got rank ` +\n          `${$filter.rank}.`);\n  util.assert(\n      x5D.shape[4] === $filter.shape[3],\n      () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match ` +\n          `input depth for filter ${$filter.shape[3]}.`);\n  util.assert(\n      eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in conv3D: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  util.assert(\n      dataFormat === 'NDHWC',\n      () => `Error in conv3d: got dataFormat of ${\n          dataFormat} but only NDHWC is currently supported.`);\n\n  const convInfo = conv_util.computeConv3DInfo(\n      x5D.shape, $filter.shape, strides, dilations, pad);\n\n  const grad = (dy: Tensor5D, saved: Tensor[]) => {\n    util.assert(\n        tupleValuesAreOne(dilations),\n        () =>\n            'Error in gradient of conv3D: dilation rates greater than 1 are ' +\n            `not yet supported in gradients. Got dilations '${dilations}'`);\n    const [x5D, $filter] = saved;\n    return {\n      x: () => conv3dDerInput_(\n          (x5D as Tensor5D).shape, dy, $filter as Tensor5D, strides, pad),\n      $filter: () => conv3dDerFilter_(\n          x5D as Tensor5D, dy, ($filter as Tensor5D).shape, strides, pad)\n    };\n  };\n\n  const res = ENGINE.runKernel((backend, save) => {\n    const res = backend.conv3d(x5D, $filter, convInfo);\n    save([x5D, $filter]);\n    return res;\n  }, {x: x5D, $filter}, grad);\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]) as\n        T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the derivative of the input of a 3D convolution.\n *\n * @param xShape The shape of the input: [batch, depth, height, width,\n * in_channels]. If length of 4, batch of 1 is assumed.\n * @param dy The derivative of the output, of rank 5 or rank 4 of shape\n *   `[batch, outDepth, outHeight, outWidth, in_channels]`.\n * If rank 4, batch of 1 is assumed.\n * @param filter The filter, rank 5, of shape\n *     `[filterDepth, filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideDepth, strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm used:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n */\nfunction conv3dDerInput_<T extends Tensor4D|Tensor5D>(\n    xShape:\n        [number, number, number, number,\n         number]|[number, number, number, number],\n    dy: T, filter: Tensor5D, strides: [number, number, number]|number,\n    pad: 'valid'|'same'): T {\n  util.assert(\n      xShape.length === dy.rank,\n      () => `Length of inShape ` +\n          `(${xShape.length}) and rank of dy (${dy.rank}) must match`);\n\n  let xShape5D = xShape as [number, number, number, number, number];\n  let dy5D = dy as Tensor5D;\n  let reshapedTo5D = false;\n  if (dy.rank === 4) {\n    reshapedTo5D = true;\n    dy5D = dy.as5D(1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]);\n    xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];\n  }\n\n  const inDepth = xShape5D[4];\n  const outDepth = dy5D.shape[4];\n  util.assert(\n      xShape5D.length === 5,\n      () =>\n          `Error in conv3dDerInput: inShape must be length 5, but got length ` +\n          `${xShape5D.length}.`);\n  util.assert(\n      dy5D.rank === 5,\n      () => `Error in conv3dDerInput: dy must be rank 5, but got ` +\n          `rank ${dy5D.rank}`);\n  util.assert(\n      filter.rank === 5,\n      () => `Error in conv3dDerInput: filter must be rank 5, but got ` +\n          `rank ${filter.rank}`);\n  util.assert(\n      inDepth === filter.shape[3],\n      () => `Error in conv3dDerInput: depth of input (${inDepth}) must ` +\n          `match input depth for filter ${filter.shape[3]}.`);\n  util.assert(\n      outDepth === filter.shape[4],\n      () => `Error in conv3dDerInput: depth of output (${outDepth}) must ` +\n          `match output depth for filter ${filter.shape[4]}.`);\n\n  const dilations = 1;\n\n  const convInfo = conv_util.computeConv3DInfo(\n      xShape5D, filter.shape, strides, dilations, pad);\n  const res = ENGINE.runKernel(\n      backend => backend.conv3dDerInput(dy5D, filter, convInfo), {dy5D});\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]) as\n        T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the derivative of the filter of a 3D convolution.\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     [batch, depth, height, width, inChannels]. If rank 4, batch of 1 is\n *     assumed.\n * @param dy The dy image, of rank 5 or rank 4, of shape\n *     [batch, depth, height, width, outDepth]. If rank 4, batch of 1 is\n *     assumed.\n * @param filterShape The shape of the filter, length 5,\n *     [filterDepth, filterHeight, filterWidth, inDepth, outDepth].\n * @param strides The strides of the convolution: [strideDepth, strideHeight,\n * strideWidth].\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n */\nfunction conv3dDerFilter_<T extends Tensor4D|Tensor5D>(\n    x: T, dy: T, filterShape: [number, number, number, number, number],\n    strides: [number, number, number]|number, pad: 'valid'|'same'): Tensor5D {\n  let x5D = x as Tensor5D;\n  if (x.rank === 4) {\n    x5D = x.as5D(1, x.shape[0], x.shape[1], x.shape[2], x.shape[3]);\n  }\n  let dy5D = dy as Tensor5D;\n  if (dy5D.rank === 4) {\n    dy5D = dy.as5D(1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]);\n  }\n  util.assert(\n      x5D.rank === 5,\n      () => `Error in conv3dDerFilter: input must be rank 5, but got shape ` +\n          `${x5D.shape}.`);\n  util.assert(\n      dy5D.rank === 5,\n      () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ` +\n          `${dy5D.shape}.`);\n  util.assert(\n      filterShape.length === 5,\n      () => `Error in conv3dDerFilter: filterShape must be length 5, but got ` +\n          `${filterShape}.`);\n  util.assert(\n      x5D.shape[4] === filterShape[3],\n      () => `Error in conv3dDerFilter: depth of input ${x5D.shape[4]}) must ` +\n          `match input depth in filter (${filterShape[3]}.`);\n  util.assert(\n      dy5D.shape[4] === filterShape[4],\n      () => `Error in conv3dDerFilter: depth of dy (${dy5D.shape[4]}) must ` +\n          `match output depth for filter (${filterShape[4]}).`);\n\n  const dilations = 1;\n\n  const convInfo = conv_util.computeConv3DInfo(\n      x5D.shape, filterShape, strides, dilations, pad);\n  return ENGINE.runKernel(\n      backend => backend.conv3dDerFilter(x5D, dy5D, convInfo), {x5D, dy5D});\n}\n\n/**\n * Computes the transposed 3D convolution of a volume, also known as a\n * deconvolution.\n *\n * @param x The input image, of rank 5 or rank 4, of shape\n *   `[batch, depth, height, width, inDepth]`. If rank 4, batch of 1 is assumed.\n * @param filter The filter, rank 4, of shape\n *     `[depth, filterHeight, filterWidth, outDepth, inDepth]`.\n *     `inDepth` must match `inDepth` in `x`.\n * @param outputShape Output shape, of rank 5 or rank 4:\n *     `[batch, depth, height, width, outDepth]`. If rank 3, batch of 1 is\n *    assumed.\n * @param strides The strides of the original convolution:\n *     `[strideDepth, strideHeight, strideWidth]`.\n * @param pad  The type of padding algorithm used in the non-transpose version\n *    of the op.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction conv3dTranspose_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike, filter: Tensor5D|TensorLike,\n    outputShape:\n        [number, number, number, number,\n         number]|[number, number, number, number],\n    strides: [number, number, number]|number, pad: 'valid'|'same'): T {\n  const $x = convertToTensor(x, 'x', 'conv3dTranspose');\n  const $filter = convertToTensor(filter, 'filter', 'conv3dTranspose');\n\n  return conv3dDerInput_(outputShape, $x, $filter, strides, pad);\n}\n\nexport const conv1d = op({conv1d_});\nexport const conv2d = op({conv2d_});\nexport const conv3d = op({conv3d_});\nexport const conv2dDerFilter = op({conv2dDerFilter_});\nexport const conv2dDerInput = op({conv2dDerInput_});\nexport const depthwiseConv2d = op({depthwiseConv2d_});\nexport const separableConv2d = op({separableConv2d_});\nexport const conv2dTranspose = op({conv2dTranspose_});\nexport const conv3dTranspose = op({conv3dTranspose_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Tensor1D, Tensor2D, Tensor3D} from '../tensor';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\n\n/**\n * Computes the dot product of two matrices, A * B. These must be matrices.\n *\n * ```js\n * const a = tf.tensor2d([1, 2], [1, 2]);\n * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * a.matMul(b).print();  // or tf.matMul(a, b)\n * ```\n * @param a First matrix in dot product operation.\n * @param b Second matrix in dot product operation.\n * @param transposeA If true, `a` is transposed before multiplication.\n * @param transposeB If true, `b` is transposed before multiplication.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\nfunction matMul_<T extends Tensor>(\n    a: T|TensorLike, b: T|TensorLike, transposeA = false,\n    transposeB = false): T {\n  let $a = convertToTensor(a, 'a', 'matMul');\n  let $b = convertToTensor(b, 'b', 'matMul');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const innerShapeA =\n      transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];\n  const innerShapeB =\n      transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];\n\n  const outerShapeA =\n      transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];\n  const outerShapeB =\n      transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];\n\n  const outerDimsA = $a.shape.slice(0, -2);\n  const outerDimsB = $b.shape.slice(0, -2);\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  util.assert(\n      $a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank,\n      () => `Error in matMul: inputs must have the same rank of at least 2, ` +\n          `got ranks ${$a.rank} and ${$b.rank}.`);\n\n  util.assert(\n      util.arraysEqual(outerDimsA, outerDimsB),\n      () => `Error in matMul: outer dimensions (${outerDimsA}) and (` +\n          `${outerDimsB}) of Tensors with shapes ${$a.shape} and ` +\n          `${$b.shape} must match.`);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${$a.shape} and ` +\n          `${$b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);\n\n  const a3D = transposeA ? $a.as3D(batchDimA, innerShapeA, outerShapeA) :\n                           $a.as3D(batchDimA, outerShapeA, innerShapeA);\n  const b3D = transposeB ? $b.as3D(batchDimB, outerShapeB, innerShapeB) :\n                           $b.as3D(batchDimB, innerShapeB, outerShapeB);\n\n  const grad = (dy: Tensor3D, saved: Tensor[]) => {\n    const [a3D, b3D] = saved as Tensor3D[];\n    if (!transposeA && !transposeB) {\n      return {\n        $a: () => dy.matMul(b3D, false, true),\n        $b: () => a3D.matMul(dy, true, false)\n      };\n    } else if (!transposeA && transposeB) {\n      return {\n        $a: () => dy.matMul(b3D, false, false),\n        $b: () => dy.matMul(a3D, true, false)\n      };\n    } else if (transposeA && !transposeB) {\n      return {\n        $a: () => b3D.matMul(dy, false, true),\n        $b: () => a3D.matMul(dy, false, false)\n      };\n    } else {\n      return {\n        $a: () => b3D.matMul(dy, true, true),\n        $b: () => dy.matMul(a3D, true, true)\n      };\n    }\n  };\n\n  const res = ENGINE.runKernel((backend, save) => {\n    const res = backend.batchMatMul(a3D, b3D, transposeA, transposeB);\n    save([a3D, b3D]);\n    return res;\n  }, {$a: a3D, $b: b3D}, grad);\n  return res.reshape(outShape) as T;\n}\n\n/**\n * Computes the outer product of two vectors, `v1` and `v2`.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([3, 4, 5]);\n *\n * tf.outerProduct(a, b).print();\n * ```\n * @param v1 The first vector in the outer product operation.\n * @param v2 The second vector in the outer product operation.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\nfunction outerProduct_(\n    v1: Tensor1D|TensorLike, v2: Tensor1D|TensorLike): Tensor2D {\n  const $v1 = convertToTensor(v1, 'v1', 'outerProduct');\n  const $v2 = convertToTensor(v2, 'v2', 'outerProduct');\n\n  util.assert(\n      $v1.rank === 1 && $v2.rank === 1,\n      () => `Error in outerProduct: inputs must be rank 1, but got ranks ` +\n          `${$v1.rank} and ${$v2.rank}.`);\n\n  return $v1.as2D(-1, 1).matMul($v2.as2D(1, -1));\n}\n\n/**\n * Computes the dot product of two matrices and/or vectors, `t1` and `t2`.\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n * const b = tf.tensor2d([[1, 2], [3, 4]]);\n * const c = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);\n *\n * a.dot(b).print();  // or tf.dot(a, b)\n * b.dot(a).print();\n * b.dot(c).print();\n * ```\n * @param t1 The first tensor in the dot operation.\n * @param t2 The second tensor in the dot operation.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\nfunction dot_(t1: Tensor|TensorLike, t2: Tensor|TensorLike): Tensor {\n  const $t1 = convertToTensor(t1, 't1', 'dot');\n  const $t2 = convertToTensor(t2, 't2', 'dot');\n  util.assert(\n      ($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2),\n      () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ` +\n          `${$t1.rank} and ${$t2.rank}.`);\n\n  const t1Inner = ($t1.rank === 1 ? $t1.size : $t1.shape[1]);\n  const t2Inner = ($t2.rank === 1 ? $t2.size : $t2.shape[0]);\n\n  util.assert(\n      t1Inner === t2Inner,\n      () => `Error in dot: inner dimensions of inputs must match, but got ` +\n          `${t1Inner} and ${t2Inner}.`);\n\n  if ($t1.rank === 1 && $t2.rank === 1) {\n    return $t1.as2D(1, -1).matMul($t2.as2D(-1, 1)).asScalar();\n  } else if ($t1.rank === 1 && $t2.rank === 2) {\n    return $t1.as2D(1, -1).matMul($t2.as2D($t2.shape[0], $t2.shape[1])).as1D();\n  } else if ($t1.rank === 2 && $t2.rank === 1) {\n    return $t1.matMul($t2.as2D(-1, 1)).as1D();\n  } else {\n    return $t1.matMul($t2.as2D($t2.shape[0], $t2.shape[1]));\n  }\n}\n\nexport const matMul = op({matMul_});\nexport const dot = op({dot_});\nexport const outerProduct = op({outerProduct_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\n\n/**\n * Reverses a `tf.Tensor1D`.\n *\n * @param x The input tensor.\n */\nfunction reverse1d_(x: Tensor1D|TensorLike): Tensor1D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 1,\n      () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);\n  return reverse($x, 0);\n}\n\n/**\n * Reverses a `tf.Tensor2D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse2d_(x: Tensor2D|TensorLike, axis?: number|number[]): Tensor2D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 2,\n      () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);\n  return reverse($x, axis);\n}\n\n/**\n * Reverses a `tf.Tensor3D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse3d_(x: Tensor3D|TensorLike, axis?: number|number[]): Tensor3D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 3,\n      () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);\n  return reverse($x, axis);\n}\n\n/**\n * Reverses a `tf.Tensor4D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse4d_(x: Tensor4D|TensorLike, axis?: number|number[]): Tensor4D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 4,\n      () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);\n  return reverse($x, axis);\n}\n\n/**\n * Reverses a `tf.Tensor` along a specified axis.\n *\n * Also available are stricter rank-specific methods that assert that `x` is\n * of the given rank:\n *   - `tf.reverse1d`\n *   - `tf.reverse2d`\n *   - `tf.reverse3d`\n *   - `tf.reverse4d`\n *\n * Except `tf.reverse1d` (which does not have axis param), all methods have\n * same signature as this method.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.reverse().print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.reverse(axis).print();\n * ```\n * @param x The input tensor to be reversed.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\nfunction reverse_<T extends Tensor>(\n    x: T|TensorLike, axis?: number|number[]): T {\n  const $x = convertToTensor(x, 'x', 'reverse');\n\n  if ($x.rank === 0) {\n    return $x.clone();\n  }\n  const axes = util.parseAxisParam(axis, $x.shape);\n  const grad = (dy: T) => {\n    return {$x: () => dy.reverse(axes)};\n  };\n  const res =\n      ENGINE.runKernel(backend => backend.reverse($x, axes), {$x}, grad);\n  return res.reshapeAs($x);\n}\n\nexport const reverse = op({reverse_});\nexport const reverse1d = op({reverse1d_});\nexport const reverse2d = op({reverse2d_});\nexport const reverse3d = op({reverse3d_});\nexport const reverse4d = op({reverse4d_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Tensor3D, Tensor4D, Tensor5D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {batchToSpaceND, spaceToBatchND} from './array_ops';\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\n\n/**\n * Computes the 2D max pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\nfunction maxPoolImpl_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number, dilations: [number, number]|number,\n    pad: 'valid'|'same'|number, dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'maxPool');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in maxPool: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n  const convInfo = conv_util.computePool2DInfo(\n      x4D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n\n  const grad = (dy: Tensor4D, saved: Tensor[]) => {\n    const [x4D, y] = saved;\n    return {\n      x: () => maxPoolBackprop(\n          dy, x4D as Tensor4D, y as Tensor4D, filterSize, strides, dilations,\n          pad)\n    };\n  };\n\n  const res = ENGINE.runKernel((backend, save) => {\n    const y = backend.maxPool(x4D, convInfo);\n    save([x4D, y]);\n    return y;\n  }, {x: x4D}, grad);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the 2D max pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction maxPool_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  return maxPoolImpl_(x, filterSize, strides, 1, pad, dimRoundingMode);\n}\n\n/**\n * Computes the 2D average pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\nfunction avgPoolImpl_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number, dilations: [number, number]|number,\n    pad: 'valid'|'same'|number, dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'avgPool', 'float32');\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in avgPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in avgPool: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool2DInfo(\n      x4D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n\n  const grad = (dy: Tensor4D) => {\n    return {\n      x: () => avgPoolBackprop(dy, x4D, filterSize, strides, dilations, pad)\n    };\n  };\n  let res = ENGINE.runKernel(\n      backend => backend.avgPool(x4D, convInfo), {x: x4D}, grad);\n  res = res.cast($x.dtype);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the 2D average pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction avgPool_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  return avgPoolImpl_(x, filterSize, strides, 1, pad, dimRoundingMode);\n}\n\n/**\n * Performs an N-D pooling operation\n *\n * @param input The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param windowShape The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param poolingType The type of pooling, either 'max' or 'avg'.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilationRate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction pool_<T extends Tensor3D|Tensor4D>(\n    input: T|TensorLike, windowShape: [number, number]|number,\n    poolingType: 'avg'|'max', pad: 'valid'|'same'|number,\n    dilations?: [number, number]|number, strides?: [number, number]|number) {\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  if (strides == null) {\n    strides = 1;\n  }\n  if (pad === 0) {\n    pad = 'valid';\n  }\n  const $x = convertToTensor(input, 'x', 'maxPool');\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in pool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  const convInfo = conv_util.computePool2DInfo(\n      x4D.shape, windowShape, strides, dilations, pad);\n  const dilation: [number, number] =\n      [convInfo.dilationHeight, convInfo.dilationWidth];\n\n  // The following implementation does batchToSpace(pool(spaceToBatch(x)))\n  // whenever dilation > 1 since the TF kernels do not support dilation > 1.\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L1037\n\n  let basePadding: number[][];\n  if (pad === 'same') {\n    basePadding = withSpaceToBatchBasePaddings(\n        [convInfo.filterHeight, convInfo.filterWidth], dilation);\n  } else {\n    basePadding = [[0, 0], [0, 0]];\n  }\n  const isDilationOne = dilation[0] === 1 && dilation[1] === 1;\n  const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings(\n      [convInfo.inHeight, convInfo.inWidth], dilation, basePadding);\n  const convertedPad = isDilationOne ? pad : 'valid';\n  const convertedX =\n      isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);\n  const forwardOp = poolingType === 'avg' ?\n      () => avgPoolImpl_(\n          convertedX, windowShape, strides, 1 /* dilation */, convertedPad) :\n      () => maxPoolImpl_(\n          convertedX, windowShape, strides, 1 /* dilation */, convertedPad);\n  const y = forwardOp();\n  const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the backprop of a 2D max pool.\n *\n * @param dy The dy error, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param input The original input image, of rank 4, of shape\n *     [batchSize, height, width, channels].\n * @param output The original output image, of rank 4, of shape\n *     [batchSize, outHeight, outWidth, channels].\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction maxPoolBackprop(\n    dy: Tensor4D|TensorLike, input: Tensor4D|TensorLike,\n    output: Tensor4D|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number, dilations: [number, number]|number,\n    pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): Tensor4D {\n  const $dy = convertToTensor(dy, 'dy', 'maxPoolBackprop');\n  const $input = convertToTensor(input, 'input', 'maxPoolBackprop');\n  const $output = convertToTensor(output, 'output', 'maxPoolBackprop');\n  util.assert(\n      $input.rank === $dy.rank,\n      () => `Rank of input (${$input.rank}) does not match rank of dy ` +\n          `(${$dy.rank})`);\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () =>\n          'Error in maxPoolBackProp: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  util.assert(\n      $dy.rank === 4,\n      () => `Error in maxPoolBackprop: dy must be rank 4 but got rank ` +\n          `${$dy.rank}.`);\n  util.assert(\n      $input.rank === 4,\n      () => `Error in maxPoolBackprop: input must be rank 4 but got rank ` +\n          `${$input.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in maxPoolBackprop: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool2DInfo(\n      $input.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n  const res = ENGINE.runKernel(\n      backend => backend.maxPoolBackprop($dy, $input, $output, convInfo),\n      {$dy, $input});\n  return res;\n}\n\n/**\n * Computes the backprop of an 2D avg pool.\n *\n * @param dy The dy error, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param input The input image, of rank 4 or rank 3 of shape\n *     [batchSize, height, width, channels]. If rank 3, batch of 1 is\n * assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n */\nfunction avgPoolBackprop<T extends Tensor3D|Tensor4D>(\n    dy: T|TensorLike, input: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number, dilations: [number, number]|number,\n    pad: 'valid'|'same'|number): T {\n  const $dy = convertToTensor(dy, 'dy', 'avgPoolBackprop');\n  const $input = convertToTensor(input, 'input', 'avgPoolBackprop');\n  util.assert(\n      $input.rank === $dy.rank,\n      () => `Rank of input (${$input.rank}) does not match rank of dy (${\n          $dy.rank})`);\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () =>\n          'Error in avgPoolBackprop: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  let input4D = $input as Tensor4D;\n  let dy4D = $dy as Tensor4D;\n  let reshapedTo4D = false;\n  if ($input.rank === 3) {\n    reshapedTo4D = true;\n    input4D = $input.as4D(1, $input.shape[0], $input.shape[1], $input.shape[2]);\n    dy4D = $dy.as4D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2]);\n  }\n\n  util.assert(\n      dy4D.rank === 4,\n      () => `Error in avgPoolBackprop: dy must be rank 4 but got rank ` +\n          `${dy4D.rank}.`);\n  util.assert(\n      input4D.rank === 4,\n      () => `Error in avgPoolBackprop: input must be rank 4 but got rank ` +\n          `${input4D.rank}.`);\n\n  const convInfo = conv_util.computePool2DInfo(\n      input4D.shape, filterSize, strides, dilations, pad);\n  const res = ENGINE.runKernel(\n      backend => backend.avgPoolBackprop(dy4D, input4D, convInfo),\n      {dy4D, input4D});\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n// Helper function to compute crops and paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/array_ops.py#L2184\nfunction requiredSpaceToBatchPaddings(\n    inputShape: [number, number], blockShape: [number, number],\n    basePadding: number[][]) {\n  const padStart = basePadding.map(b => b[0]);\n  const origPadEnd = basePadding.map(b => b[1]);\n  const fullInputShape = inputShape.concat(padStart, origPadEnd);\n  const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);\n  const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);\n  const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);\n  const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);\n  return [paddings, crops];\n}\n\n// Helper function to compute base paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L524\nfunction withSpaceToBatchBasePaddings(\n    filterShape: [number, number], dilation: [number, number]) {\n  // Spatial dimensions of the filters and the upsampled filters in which we\n  // introduce (rate - 1) zeros between consecutive filter values.\n  const dilatedFilterShape = filterShape.map((s, i) => {\n    return s + (s - 1) * (dilation[i] - 1);\n  });\n  const padExtraShape = dilatedFilterShape.map(s => s - 1);\n\n  // When padding is odd, we pad more at end, following the same\n  // convention as conv2d.\n  const padExtraStart = padExtraShape.map(s => Math.floor(s / 2));\n  const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);\n  return padExtraShape.map((_, i) => {\n    return [padExtraStart[i], padExtraEnd[i]];\n  });\n}\n\n/**\n * Computes the 3D average pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.avgPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction avgPool3d_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike,\n    filterSize: [number, number, number]|number,\n    strides: [number, number, number]|number,\n    pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC',\n    dilations?: [number, number, number]|number,\n    ): T {\n  const $x = convertToTensor(x, 'x', 'avgPool3d', 'float32');\n\n  let x5D = $x as Tensor5D;\n  let reshapedTo5D = false;\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = $x.as5D(1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]);\n  }\n\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n  util.assert(\n      x5D.rank === 5,\n      () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n  util.assert(\n      dataFormat === 'NDHWC',\n      () => `Error in avgPool3d: Only NDHWC is currently supported, ` +\n          `but got dataFormat of ${dataFormat}`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in avgPool3d: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in avgPool3d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(\n      x5D.shape, filterSize, strides, dilations, pad, dimRoundingMode,\n      dataFormat);\n\n  const grad = (dy: Tensor5D) => {\n    return {\n      x: () => avgPool3dBackprop(\n          dy, x5D, filterSize, strides, dilations, pad, dimRoundingMode)\n    };\n  };\n\n  let res = ENGINE.runKernel(\n      backend => backend.avgPool3d(x5D, convInfo), {x: x5D}, grad);\n  res = res.cast(x5D.dtype);\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]) as\n        T;\n  }\n\n  return res as T;\n}\n\n/**\n * Computes the backprop of a 3d avg pool.\n *\n * @param dy The dy error, of rank 5 of shape\n *     [batchSize, depth, height, width, channels].\n * assumed.\n * @param input The original input image, of rank 5 or rank4 of shape\n *     [batchSize, depth, height, width, channels].\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction avgPool3dBackprop<T extends Tensor4D|Tensor5D>(\n    dy: T|TensorLike, input: T|TensorLike,\n    filterSize: [number, number, number]|number,\n    strides: [number, number, number]|number,\n    dilations: [number, number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $dy = convertToTensor(dy, 'dy', 'avgPool3dBackprop');\n  const $input = convertToTensor(input, 'input', 'avgPool3dBackprop');\n\n  let dy5D = $dy as Tensor5D;\n  let input5D = $input as Tensor5D;\n  let reshapedTo5D = false;\n  if ($input.rank === 4) {\n    reshapedTo5D = true;\n    dy5D = $dy.as5D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]);\n    input5D = $input.as5D(\n        1, $input.shape[0], $input.shape[1], $input.shape[2], $input.shape[3]);\n  }\n\n  util.assert(\n      dy5D.rank === 5,\n      () => `Error in avgPool3dBackprop: dy must be rank 5 but got rank ` +\n          `${dy5D.rank}.`);\n  util.assert(\n      input5D.rank === 5,\n      () => `Error in avgPool3dBackprop: input must be rank 5 but got rank ` +\n          `${input5D.rank}.`);\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in avgPool3dBackprop: Either strides or dilations ' +\n          `must be 1. Got strides ${strides} and dilations '${dilations}'`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in maxPool3dBackprop: pad must be an integer when ` +\n            `using, dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(\n      input5D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n  const res = ENGINE.runKernel(\n      backend => backend.avgPool3dBackprop(dy5D, input5D, convInfo),\n      {dy5D, input5D});\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]) as\n        T;\n  }\n\n  return res as T;\n}\n\n/**\n * Computes the 3D max pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.maxPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dimRoundingMode The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction maxPool3d_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike, filterSize: [number, number, number]|number,\n    strides: [number, number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC',\n    dilations?: [number, number, number]|number): T {\n  const $x = convertToTensor(x, 'x', 'maxPool3d');\n\n  let x5D = $x as Tensor5D;\n  let reshapedTo5D = false;\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = $x.as5D(1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]);\n  }\n\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n  util.assert(\n      x5D.rank === 5,\n      () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n  util.assert(\n      dataFormat === 'NDHWC',\n      () => `Error in maxPool3d: Only NDHWC is currently supported, ` +\n          `but got dataFormat of ${dataFormat}`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in maxPool3d: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in maxPool3d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(\n      x5D.shape, filterSize, strides, dilations, pad, dimRoundingMode,\n      dataFormat);\n\n  const grad = (dy: Tensor5D, saved: Tensor[]) => {\n    const [x5D, y] = saved;\n    return {\n      x: () => maxPool3dBackprop(\n          dy, x5D as Tensor5D, y as Tensor5D, filterSize, strides, dilations,\n          pad, dimRoundingMode)\n    };\n  };\n\n  const res = ENGINE.runKernel((backend, save) => {\n    const y = backend.maxPool3d(x5D, convInfo);\n    save([x5D, y]);\n    return y;\n  }, {x: x5D}, grad);\n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]) as\n        T;\n  }\n\n  return res as T;\n}\n\n/**\n * Computes the backprop of a 3d max pool.\n *\n * @param dy The dy error, of rank 5 of shape\n *     [batchSize, depth, height, width, channels].\n * assumed.\n * @param input The original input image, of rank 5 or rank 4 of shape\n *     [batchSize, depth, height, width, channels].\n * @param output The original output image, of rank 5 of shape\n *     [batchSize, outDepth, outHeight, outWidth, channels].\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates:\n *     `[dilationDepth, dilationHeight, dilationWidth]`\n *     in which we sample input values across the depth, height and width\n *     dimensions in dilated pooling.\n *     Defaults to `[1, 1, 1]`. If `dilations` is a single number,\n *     then `dilationDepth == dilationHeight == dilationWidth`.\n *     If it is greater than 1, then all values of `strides` must be 1.\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction maxPool3dBackprop<T extends Tensor4D|Tensor5D>(\n    dy: T|TensorLike, input: T|TensorLike, output: T|TensorLike,\n    filterSize: [number, number, number]|number,\n    strides: [number, number, number]|number,\n    dilations: [number, number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $dy = convertToTensor(dy, 'dy', 'maxPool3dBackprop');\n  const $input = convertToTensor(input, 'input', 'maxPool3dBackprop');\n  const $output = convertToTensor(output, 'output', 'maxPool3dBackprop');\n\n  let dy5D = $dy as Tensor5D;\n  let input5D = $input as Tensor5D;\n  let output5D = $output as Tensor5D;\n  let reshapedTo5D = false;\n  if ($input.rank === 4) {\n    reshapedTo5D = true;\n    dy5D = $dy.as5D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]);\n    input5D = $input.as5D(\n        1, $input.shape[0], $input.shape[1], $input.shape[2], $input.shape[3]);\n    output5D = $output.as5D(\n        1, $output.shape[0], $output.shape[1], $output.shape[2],\n        $output.shape[3]);\n  }\n\n  util.assert(\n      dy5D.rank === 5,\n      () => `Error in maxPool3dBackprop: dy must be rank 5 but got rank ` +\n          `${dy5D.rank}.`);\n  util.assert(\n      input5D.rank === 5,\n      () => `Error in maxPool3dBackprop: input must be rank 5 but got rank ` +\n          `${input5D.rank}.`);\n  util.assert(\n      output5D.rank === 5,\n      () => `Error in maxPool3dBackprop: output must be rank 5 but got rank ` +\n          `${output5D.rank}.`);\n  if (dilations == null) {\n    dilations = [1, 1, 1];\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in maxPool3dBackprop: Either strides or dilations ' +\n          `must be 1. Got strides ${strides} and dilations '${dilations}'`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in maxPool3dBackprop: pad must be an integer when ` +\n            `using, dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computePool3DInfo(\n      input5D.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n  const res = ENGINE.runKernel(\n      backend => backend.maxPool3dBackprop(dy5D, input5D, output5D, convInfo),\n      {dy5D, input5D});\n  \n  if (reshapedTo5D) {\n    return res.as4D(res.shape[1], res.shape[2], res.shape[3], res.shape[4]) as\n        T;\n  }\n\n  return res as T;\n}\n\nexport const maxPool = op({maxPool_});\nexport const avgPool = op({avgPool_});\nexport const pool = op({pool_});\nexport const maxPool3d = op({maxPool3d_});\nexport const avgPool3d = op({avgPool3d_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\nimport * as slice_util from './slice_util';\n\n/**\n * Extracts a 1D slice from 1D array starting at coordinates `begin` and is\n * of length `size`. See `slice` for details.\n */\nfunction slice1d_(\n    x: Tensor1D|TensorLike, begin: number, size: number): Tensor1D {\n  const $x = convertToTensor(x, 'x', 'slice1d');\n  util.assert(\n      $x.rank === 1,\n      () =>\n          `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, [begin], [size]);\n}\n\n/**\n * Extracts a 2D slice from a 2D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice2d_(\n    x: Tensor2D|TensorLike, begin: [number, number],\n    size: [number, number]): Tensor2D {\n  const $x = convertToTensor(x, 'x', 'slice2d');\n  util.assert(\n      $x.rank === 2,\n      () =>\n          `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\n\n/**\n * Extracts a 3D slice from a 3D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice3d_(\n    x: Tensor3D|TensorLike, begin: [number, number, number],\n    size: [number, number, number]): Tensor3D {\n  const $x = convertToTensor(x, 'x', 'slice3d');\n  util.assert(\n      $x.rank === 3,\n      () =>\n          `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\n\n/**\n * Extracts a 4D slice from a 4D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice4d_(\n    x: Tensor4D|TensorLike, begin: [number, number, number, number],\n    size: [number, number, number, number]): Tensor4D {\n  const $x = convertToTensor(x, 'x', 'slice4d');\n  util.assert(\n      $x.rank === 4,\n      () =>\n          `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\n\n/**\n * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`\n * and is of size `size`.\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `x` is of the given rank:\n *   - `tf.slice1d`\n *   - `tf.slice2d`\n *   - `tf.slice3d`\n *   - `tf.slice4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.slice([1], [2]).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * x.slice([1, 0], [1, 2]).print();\n * ```\n * @param x The input `tf.Tensor` to slice from.\n * @param begin The coordinates to start the slice from. The length can be\n *     less than the rank of x - the rest of the axes will have implicit 0 as\n *     start. Can also be a single number, in which case it specifies the\n *     first axis.\n * @param size The size of the slice. The length can be less than the rank of\n *     x - the rest of the axes will have implicit -1. A value of -1 requests\n *     the rest of the dimensions in the axis. Can also be a single number,\n *     in which case it specifies the size of the first axis.\n */\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\nfunction slice_<R extends Rank, T extends Tensor<R>>(\n    x: T|TensorLike, begin: number|number[], size?: number|number[]): T {\n  const $x = convertToTensor(x, 'x', 'slice');\n\n  if ($x.rank === 0) {\n    throw new Error('Slicing scalar is not possible');\n  }\n  // The following logic allows for more ergonomic calls.\n  let begin_: number[];\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array($x.rank - 1).fill(0)];\n  } else if (begin.length < $x.rank) {\n    begin_ = begin.concat(new Array($x.rank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(\n        d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_: number[];\n  if (size == null) {\n    size_ = new Array($x.rank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array($x.rank - 1).fill(-1)];\n  } else if (size.length < $x.rank) {\n    size_ = size.concat(new Array($x.rank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(\n          d === -1,\n          () => `Negative size values should be exactly -1 but got ` +\n              `${d} for the slice() size at index ${i}.`);\n      return $x.shape[i] - begin_[i];\n    }\n  });\n  slice_util.assertParamsValid($x, begin_, size_);\n  const inputShape = $x.shape;\n  const grad = (dy: T) => {\n    // Create an Nx2 padding where the first column represents how many\n    // zeros are prepended (at start) for each dimension, and the second\n    // column indicates how many zeros are appended (at end).\n\n    // The number of zeros to append is the shape of the input\n    // elementwise-subtracted by both the begin vector and sizes vector.\n    const paddings: Array<[number, number]> = [];\n    for (let i = 0; i < dy.rank; i++) {\n      paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);\n    }\n    return {$x: () => dy.pad(paddings)};\n  };\n  return ENGINE.runKernel(\n      backend => backend.slice($x, begin_, size_), {$x}, grad);\n}\n\nexport const slice = op({slice_});\nexport const slice1d = op({slice1d_});\nexport const slice2d = op({slice2d_});\nexport const slice3d = op({slice3d_});\nexport const slice4d = op({slice4d_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {customGrad} from '../gradients';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport * as axis_util from './axis_util';\nimport {op} from './operation';\nimport {ones, scalar, zerosLike} from './tensor_ops';\n\n/**\n * Computes the log(sum(exp(elements across the reduction dimensions)).\n *\n * Reduces the input along the dimensions given in `axis`. Unless `keepDims`\n * is true, the rank of the array is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and an array with a\n * single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.logSumExp().print();  // or tf.logSumExp(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.logSumExp(axis).print();  // or tf.logSumExp(a, axis)\n * ```\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. If null (the default),\n *     reduces all dimensions.\n * @param keepDims If true, retains reduced dimensions with length\n *     of 1. Defaults to false.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction logSumExp_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'logSumExp');\n\n  const axes = util.parseAxisParam(axis, $x.shape);\n  const xMax = $x.max(axes, true /* keepDims */);\n  const a = $x.sub(xMax);\n  const b = a.exp();\n  const c = b.sum(axes);\n  const d = c.log();\n  const res = xMax.reshape(d.shape).add(d);\n\n  if (keepDims) {\n    const newShape = axis_util.expandShapeToKeepDim(res.shape, axes);\n    return res.reshape(newShape) as T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the sum of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If axes has no entries, all dimensions are reduced, and a\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.sum().print();  // or tf.sum(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.sum(axis).print();  // or tf.sum(x, axis)\n * ```\n *\n * @param x The input tensor to compute the sum over. If the dtype is `bool`\n *   it will be converted to `int32` and the output dtype will be `int32`.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction sum_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'sum');\n\n  if ($x.dtype === 'bool') {\n    $x = $x.toInt();\n  }\n  const axes = util.parseAxisParam(axis, $x.shape);\n\n  // Use a custom gradient to bypass 2 gradient backprops since sum is used\n  // extremely often.\n  const customOp = customGrad((x: Tensor) => {\n    const permutation = axis_util.getAxesPermutation(axes, x.rank);\n    let reductionAxes = axes;\n    let permutedX = x;\n    if (permutation != null) {\n      permutedX = x.transpose(permutation);\n      reductionAxes = axis_util.getInnerMostAxes(reductionAxes.length, x.rank);\n    }\n    let value = ENGINE.runKernel(\n        backend => backend.sum(permutedX, reductionAxes), {permutedX});\n    if (keepDims) {\n      const newShape = axis_util.expandShapeToKeepDim(value.shape, axes);\n      value = value.reshape(newShape);\n    }\n\n    const gradFunc = (dy: Tensor) => {\n      const expandedDyShape = x.shape.slice();\n      axes.forEach(axis => {\n        expandedDyShape[axis] = 1;\n      });\n      const expandedDy = dy.reshape(expandedDyShape);\n      const derX = expandedDy.mul(ones(x.shape, 'float32'));\n      return derX;\n    };\n    return {value, gradFunc};\n  });\n\n  return customOp($x) as T;\n}\n\n/**\n * Computes the product of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and a\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.prod().print();  // or tf.prod(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.prod(axis).print();  // or tf.prod(x, axis)\n * ```\n *\n * @param x The input tensor to compute the product over. If the dtype is `bool`\n *   it will be converted to `int32` and the output dtype will be `int32`.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction prod_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'prod');\n\n  if ($x.dtype === 'bool') {\n    $x = $x.toInt();\n  }\n  const axes = util.parseAxisParam(axis, $x.shape);\n\n  const permutation = axis_util.getAxesPermutation(axes, $x.rank);\n  let reductionAxes = axes;\n  let permutedX = $x;\n  if (permutation != null) {\n    permutedX = $x.transpose(permutation);\n    reductionAxes = axis_util.getInnerMostAxes(reductionAxes.length, $x.rank);\n  }\n  let value = ENGINE.runKernel(\n      backend => backend.prod(permutedX, reductionAxes), {permutedX});\n  if (keepDims) {\n    const newShape = axis_util.expandShapeToKeepDim(value.shape, axes);\n    value = value.reshape(newShape);\n  }\n\n  return value as T;\n}\n/**\n * Computes the mean of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is\n * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with\n * a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.mean().print();  // or tf.mean(a)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.mean(axis).print();  // or tf.mean(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction mean_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'mean');\n\n  const axes = util.parseAxisParam(axis, $x.shape);\n  const shapes = axis_util.computeOutAndReduceShapes($x.shape, axes);\n  const reduceShape = shapes[1];\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  // Use a custom gradient to bypass 2 gradient backprops since mean is used\n  // extremely often.\n  const customOp = customGrad((x: Tensor) => {\n    const reduceSizeScalar = scalar(reduceSize);\n    // Cast if needed.\n    const xReduce =\n        reduceSizeScalar.dtype === x.dtype ? x : x.cast(reduceSizeScalar.dtype);\n    const res = xReduce.div(reduceSizeScalar);\n    const value = res.sum(axis, keepDims);\n\n    const gradFunc = (dy: Tensor) => {\n      const expandedDyShape = x.shape.slice();\n      axes.forEach(axis => {\n        expandedDyShape[axis] = 1;\n      });\n      const expandedDy = dy.reshape(expandedDyShape);\n      const derX = expandedDy.mul(ones(x.shape, 'float32')).div(reduceSize);\n      return derX;\n    };\n    return {value, gradFunc};\n  });\n\n  return customOp($x) as T;\n}\n\n/**\n * Gradient helper function for the min and max operations.\n */\nfunction gradForMinAndMax<T extends Tensor>(\n    dy: T, y: T, xOrig: Tensor, origAxes: number[], permutedAxes: number[]) {\n  if (y.rank < xOrig.rank) {\n    y = y.reshape(axis_util.expandShapeToKeepDim(y.shape, origAxes)) as T;\n  }\n  if (dy.rank < xOrig.rank) {\n    dy = dy.reshape(axis_util.expandShapeToKeepDim(dy.shape, origAxes)) as T;\n  }\n  return {\n    $x: () => {\n      const dx = dy.mul(xOrig.equal(y).cast(dy.dtype));\n      return permutedAxes == null ? dx : dx.transpose(permutedAxes);\n    }\n  };\n}\n\n/**\n * Computes the minimum value from the input.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the array is reduced by 1 for each entry in `axes`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axes` has no entries, all dimensions are reduced, and an array with a\n * single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.min().print();  // or tf.min(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.min(axis).print();  // or tf.min(x, axis)\n * ```\n *\n * @param x The input Tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction min_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'min');\n  const xOrig = $x;\n\n  const origAxes = util.parseAxisParam(axis, $x.shape);\n  let axes = origAxes;\n  const permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);\n  if (permutedAxes != null) {\n    $x = $x.transpose(permutedAxes);\n    axes = axis_util.getInnerMostAxes(axes.length, $x.rank);\n  }\n\n  const grad = (dy: T, saved: Tensor[]) =>\n      gradForMinAndMax(dy, saved[1], saved[0], origAxes, permutedAxes);\n  let res = ENGINE.runKernel((backend, save) => {\n    const y = backend.min($x, axes);\n    save([xOrig, y]);\n    return y as T;\n  }, {$x}, grad);\n  if (keepDims) {\n    const newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);\n    res = res.reshape(newShape) as T;\n  }\n  return res;\n}\n\n/**\n * Computes the maximum of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and an\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.max().print();  // or tf.max(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.max(axis).print();  // or tf.max(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction max_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'max');\n  const xOrig = $x;\n\n  const origAxes = util.parseAxisParam(axis, $x.shape);\n  let axes = origAxes;\n  const permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);\n  if (permutedAxes != null) {\n    $x = $x.transpose(permutedAxes);\n    axes = axis_util.getInnerMostAxes(axes.length, $x.rank);\n  }\n\n  const grad = (dy: T, saved: Tensor[]) =>\n      gradForMinAndMax(dy, saved[1], saved[0], origAxes, permutedAxes);\n  let res = ENGINE.runKernel((backend, save) => {\n    const y = backend.max($x, axes);\n    save([xOrig, y]);\n    return y;\n  }, {$x}, grad);\n  if (keepDims) {\n    const newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);\n    res = res.reshape(newShape) as T;\n  }\n  return res as T;\n}\n\n/**\n * Returns the indices of the minimum values along an `axis`.\n *\n * The result has the same shape as `input` with the dimension along `axis`\n * removed.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.argMin().print();  // or tf.argMin(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n *\n * const axis = 1;\n * x.argMin(axis).print();  // or tf.argMin(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension to reduce. Defaults to 0 (outer-most dimension).\n *\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction argMin_<T extends Tensor>(x: Tensor|TensorLike, axis = 0): T {\n  let $x = convertToTensor(x, 'x', 'argMin');\n\n  if (axis == null) {\n    axis = 0;\n  }\n  let axes = util.parseAxisParam(axis, $x.shape);\n  const permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);\n  if (permutedAxes != null) {\n    $x = $x.transpose(permutedAxes);\n    axes = axis_util.getInnerMostAxes(axes.length, $x.rank);\n  }\n  const grad = (dy: T, saved: Tensor[]) => {\n    const [$x] = saved;\n    return {$x: () => zerosLike($x)};\n  };\n  return ENGINE.runKernel((backend, save) => {\n    const res = backend.argMin($x, axes[0]);\n    save([$x]);\n    return res;\n  }, {$x}, grad) as T;\n}\n\n/**\n * Returns the indices of the maximum values along an `axis`.\n *\n * The result has the same shape as `input` with the dimension along `axis`\n * removed.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.argMax().print();  // or tf.argMax(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n *\n * const axis = 1;\n * x.argMax(axis).print();  // or tf.argMax(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension to reduce. Defaults to 0 (outer-most dimension).\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction argMax_<T extends Tensor>(x: Tensor|TensorLike, axis = 0): T {\n  let $x = convertToTensor(x, 'x', 'argMax');\n\n  if (axis == null) {\n    axis = 0;\n  }\n  let axes = util.parseAxisParam(axis, $x.shape);\n  const permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);\n  if (permutedAxes != null) {\n    $x = $x.transpose(permutedAxes);\n    axes = axis_util.getInnerMostAxes(axes.length, $x.rank);\n  }\n  const grad = (dy: T, saved: Tensor[]) => {\n    const [$x] = saved;\n    return {$x: () => zerosLike($x)};\n  };\n  return ENGINE.runKernel((backend, save) => {\n    const res = backend.argMax($x, axes[0]);\n    save([$x]);\n    return res;\n  }, {$x}, grad) as T;\n}\n\n/**\n * Computes the logical and of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and an\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 1, 1], 'bool');\n *\n * x.all().print();  // or tf.all(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');\n *\n * const axis = 1;\n * x.all(axis).print();  // or tf.all(x, axis)\n * ```\n *\n * @param x The input tensor. Must be of dtype bool.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction all_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'all', 'bool');\n\n  const origAxes = util.parseAxisParam(axis, $x.shape);\n  let axes = origAxes;\n  const permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);\n  if (permutedAxes != null) {\n    $x = $x.transpose(permutedAxes);\n    axes = axis_util.getInnerMostAxes(axes.length, $x.rank);\n  }\n  const res = ENGINE.runKernel(backend => backend.all($x, axes), {$x});\n  if (keepDims) {\n    const newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);\n    return res.reshape(newShape) as T;\n  }\n  return res as T;\n}\n\n/**\n * Computes the logical or of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and an\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 1, 1], 'bool');\n *\n * x.any().print();  // or tf.any(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');\n *\n * const axis = 1;\n * x.any(axis).print();  // or tf.any(x, axis)\n * ```\n *\n * @param x The input tensor. Must be of dtype bool.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction any_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'any', 'bool');\n\n  const origAxes = util.parseAxisParam(axis, $x.shape);\n  let axes = origAxes;\n  const permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);\n  if (permutedAxes != null) {\n    $x = $x.transpose(permutedAxes);\n    axes = axis_util.getInnerMostAxes(axes.length, $x.rank);\n  }\n  const res = ENGINE.runKernel(backend => backend.any($x, axes), {$x});\n  if (keepDims) {\n    const newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);\n    return res.reshape(newShape) as T;\n  }\n  return res as T;\n}\n\n/**\n * Calculates the mean and variance of `x`. The mean and variance are\n * calculated by aggregating the contents of `x` across `axes`. If `x` is\n * 1-D and `axes = [0]` this is just the mean and variance of a vector.\n *\n * @param x The input tensor.\n * @param axis The dimension(s) along with to compute mean and\n *     variance. By default it reduces all dimensions.\n * @param keepDims If true, the moments have the same dimensionality as the\n *     input.\n * @return An object with two keys: `mean` and `variance`.\n */\n/** @doc {heading: 'Operations', subheading: 'Normalization'} */\nfunction moments_(\n    x: Tensor|TensorLike, axis: number|number[] = null,\n    keepDims = false): {mean: Tensor, variance: Tensor} {\n  x = convertToTensor(x, 'x', 'moments');\n  const axes = util.parseAxisParam(axis, x.shape);\n  const mean = x.mean(axes, keepDims);\n  let keepDimsShape = mean.shape;\n  if (!keepDims) {\n    keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);\n  }\n  const devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();\n  const variance = devSquared.mean(axes, keepDims);\n  return {mean, variance};\n}\n\nexport const all = op({all_});\n// tslint:disable-next-line:variable-name\nexport const any = op({any_});\nexport const argMax = op({argMax_});\nexport const argMin = op({argMin_});\nexport const logSumExp = op({logSumExp_});\nexport const max = op({max_});\nexport const mean = op({mean_});\nexport const min = op({min_});\nexport const moments = op({moments_});\nexport const sum = op({sum_});\nexport const prod = op({prod_});\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {maximum} from './binary_ops';\nimport {getReductionAxes} from './broadcast_util';\nimport {where} from './logical_ops';\nimport {op} from './operation';\nimport {SELU_SCALE, SELU_SCALEALPHA} from './selu_util';\nimport {scalar, zerosLike} from './tensor_ops';\n\n/**\n * Computes rectified linear element-wise: `max(x, 0)`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.relu().print();  // or tf.relu(x)\n * ```\n * @param x The input tensor. If the dtype is `bool`, the output dtype will be\n *     `int32'.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction relu_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'relu');\n\n  if ($x.dtype === 'bool') {\n    return $x.toInt();\n  }\n  const grad = (dy: T, saved: Tensor[]) => {\n    const [$x] = saved;\n    return {$x: () => dy.mulStrict($x.step().toFloat() as T)};\n  };\n  return ENGINE.runKernel((backend, save) => {\n    const res = backend.relu($x);\n    save([$x]);\n    return res;\n  }, {$x}, grad);\n}\n\n/**\n * Computes exponential linear element-wise: `x > 0 ? e ^ x - 1 : 0`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 1, -3, 2]);\n *\n * x.elu().print();  // or tf.elu(x)\n * ```\n * @param x The input tensor.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction elu_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'elu');\n\n  const grad = (dy: T, saved: Tensor[]) => {\n    const [y] = saved;\n    return {\n      $x: () => ENGINE.runKernel(backend => backend.eluDer(dy, y), {dy, y}) as T\n    };\n  };\n  return ENGINE.runKernel((backend, save) => {\n    const y = backend.elu($x);\n    save([y]);\n    return y;\n  }, {$x}, grad);\n}\n\n/**\n * Computes scaled exponential linear element-wise.\n *\n * `x < 0 ? scale * alpha * (exp(x) - 1) : x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.selu().print();  // or tf.selu(x)\n * ```\n * @param x The input tensor.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction selu_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'selu');\n\n  const grad = (dy: T, saved: Tensor[]) => {\n    const [$x] = saved;\n    return {\n      $x: () => {\n        const mask = $x.greater(scalar(0));\n\n        const scaleAlpha = scalar(SELU_SCALEALPHA);\n        const scale = scalar(SELU_SCALE);\n\n        const greaterThanZeroDer = dy.mul(scale);\n        const lessEqualZeroDer = dy.mul(scaleAlpha).mul($x.toFloat().exp());\n\n        return where(mask, greaterThanZeroDer, lessEqualZeroDer) as T;\n      }\n    };\n  };\n  return ENGINE.runKernel((backend, save) => {\n    const res = backend.selu($x);\n    save([$x]);\n    return res;\n  }, {$x}, grad);\n}\n\n/**\n * Computes leaky rectified linear element-wise.\n *\n * See\n * [http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf](\n *     http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf)\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)\n * ```\n * @param x The input tensor.\n * @param alpha The scaling factor for negative values, defaults to 0.2.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction leakyRelu_<T extends Tensor>(x: T|TensorLike, alpha = 0.2): T {\n  const $x = convertToTensor(x, 'x', 'leakyRelu');\n  return maximum(scalar(alpha).mul($x), $x);\n}\n\n/**\n * Computes leaky rectified linear element-wise with parametric alphas.\n *\n * `x < 0 ? alpha * x : f(x) = x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n * const alpha = tf.scalar(0.1);\n *\n * x.prelu(alpha).print();  // or tf.prelu(x, alpha)\n * ```\n * @param x The input tensor.\n * @param alpha Scaling factor for negative values.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction prelu_<T extends Tensor>(x: T|TensorLike, alpha: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'prelu');\n  const $alpha = convertToTensor(alpha, 'alpha', 'prelu');\n\n  const grad = (dy: Tensor, saved: Tensor[]) => {\n    const [$x, $alpha] = saved;\n    const mask = $x.greater(0);\n\n    return {\n      $x: () => where(mask, dy, dy.mul($alpha)) as T,\n      $alpha: () => {\n        let res = where(mask, zerosLike(dy), dy.mul($x));\n        const reduceAxes = getReductionAxes($alpha.shape, dy.shape);\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n        return res.reshape($alpha.shape) as T;\n      }\n    };\n  };\n\n  return ENGINE.runKernel((backend, save) => {\n    const res = backend.prelu($x, $alpha);\n    save([$x, $alpha]);\n    return res;\n  }, {$x, $alpha}, grad) as T;\n}\n\nexport const elu = op({elu_});\nexport const leakyRelu = op({leakyRelu_});\nexport const prelu = op({prelu_});\nexport const relu = op({relu_});\nexport const selu = op({selu_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport * as axis_util from './axis_util';\nimport {op} from './operation';\n\n/**\n * Transposes the `tf.Tensor`. Permutes the dimensions according to `perm`.\n *\n * The returned `tf.Tensor`'s dimension `i` will correspond to the input\n * dimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,\n * where `n` is the rank of the input `tf.Tensor`. Hence by default, this\n * operation performs a regular matrix transpose on 2-D input `tf.Tensor`s.\n *\n * ```js\n * const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);\n *\n * a.transpose().print();  // or tf.transpose(a)\n * ```\n *\n * @param x The tensor to transpose.\n * @param perm The permutation of the dimensions of a.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\nfunction transpose_<T extends Tensor>(x: T|TensorLike, perm?: number[]): T {\n  const $x = convertToTensor(x, 'x', 'transpose');\n\n  if (perm == null) {\n    perm = $x.shape.map((s, i) => i).reverse();\n  }\n  util.assert(\n      $x.rank === perm.length,\n      () => `Error in transpose: rank of input ${$x.rank} ` +\n          `must match length of perm ${perm}.`);\n  perm.forEach(axis => {\n    util.assert(\n        axis >= 0 && axis < $x.rank,\n        () => `All entries in 'perm' must be between 0 and ${$x.rank - 1}` +\n            ` but got ${perm}`);\n  });\n\n  if ($x.rank <= 1) {\n    return $x.clone();\n  }\n\n  const der = (dy: T) => {\n    const undoPerm = axis_util.getUndoAxesPermutation(perm);\n    return {$x: () => dy.transpose(undoPerm)};\n  };\n  return ENGINE.runKernel(backend => backend.transpose($x, perm), {$x}, der);\n}\n\nexport const transpose = op({transpose_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\n\n/**\n * Normalizes the activation of a local neighborhood across or within\n * channels.\n *\n * @param x The input tensor. The 4-D input tensor is treated as a 3-D array\n *     of 1D vectors (along the last dimension), and each vector is\n *     normalized independently.\n * @param depthRadius The number of adjacent channels in the 1D normalization\n *     window.\n * @param bias A constant bias term for the basis.\n * @param alpha A scale factor, usually positive.\n * @param beta An exponent.\n */\n/** @doc {heading: 'Operations', subheading: 'Normalization'} */\nfunction localResponseNormalization_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5): T {\n  const $x = convertToTensor(x, 'x', 'localResponseNormalization');\n  util.assert(\n      $x.rank === 4 || $x.rank === 3,\n      () => `Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${$x.rank}.`);\n  util.assert(\n      util.isInt(depthRadius),\n      () => `Error in localResponseNormalization: depthRadius must be an ` +\n          `integer but got depthRadius ${depthRadius}.`);\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n  const backward = (dy: Tensor4D, saved: Tensor[]) => {\n    const [x4D, y] = saved;\n    return {\n      x4D: () => ENGINE.runKernel(\n          backend => backend.LRNGrad(\n              dy, x4D as Tensor4D, y as Tensor4D, depthRadius, bias, alpha,\n              beta),\n          {})\n    };\n  };\n  const res = ENGINE.runKernel((backend, save) => {\n    const y = backend.localResponseNormalization4D(\n        x4D, depthRadius, bias, alpha, beta);\n    save([x4D, y]);\n    return y;\n  }, {x4D}, backward);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  } else {\n    return res as T;\n  }\n}\n\nexport const localResponseNormalization = op({localResponseNormalization_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {parseAxisParam} from '../util';\n\nimport * as axis_util from './axis_util';\nimport {op} from './operation';\nimport {scalar} from './tensor_ops';\n\n/**\n * Computes the norm of scalar, vectors, and matrices.\n * This function can compute several different vector norms (the 1-norm, the\n * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\n * and matrix norms (Frobenius, 1-norm, and inf-norm).\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.norm().print();  // or tf.norm(x)\n * ```\n *\n * @param x The input array.\n * @param ord Optional. Order of the norm. Supported norm types are\n * following:\n *\n *  | ord        | norm for matrices         | norm for vectors\n *  |------------|---------------------------|---------------------\n *  |'euclidean' |Frobenius norm             |2-norm\n *  |'fro'       |Frobenius norm\t           |\n *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n *  |2           |                           |sum(abs(x)^2)^1/2*\n *\n * @param axis Optional. If axis is null (the default), the input is\n * considered a vector and a single vector norm is computed over the entire\n * set of values in the Tensor, i.e. norm(x, ord) is equivalent\n * to norm(x.reshape([-1]), ord). If axis is a integer, the input\n * is considered a batch of vectors, and axis determines the axis in x\n * over which to compute vector norms. If axis is a 2-tuple of integer it is\n * considered a batch of matrices and axis determines the axes in NDArray\n * over which to compute a matrix norm.\n * @param keepDims Optional. If true, the norm have the same dimensionality\n * as the input.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\nfunction norm_(\n    x: Tensor|TensorLike, ord: number|'euclidean'|'fro' = 'euclidean',\n    axis: number|number[] = null, keepDims = false): Tensor {\n  x = convertToTensor(x, 'x', 'norm');\n\n  const norm = normImpl(x, ord, axis);\n  let keepDimsShape = norm.shape;\n  if (keepDims) {\n    const axes = parseAxisParam(axis, x.shape);\n    keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\n  }\n  return norm.reshape(keepDimsShape);\n}\n\nfunction normImpl(\n    x: Tensor, p: number|string, axis: number|number[] = null): Tensor {\n  if (x.rank === 0) {\n    return x.abs();\n  }\n\n  // consider vector when no axis is specified\n  if (x.rank !== 1 && axis === null) {\n    return normImpl(x.reshape([-1]), p, axis);\n  }\n\n  // vector\n  if (x.rank === 1 || typeof axis === 'number' ||\n      Array.isArray(axis) && axis.length === 1) {\n    if (p === 1) {\n      return x.abs().sum(axis);\n    }\n    if (p === Infinity) {\n      return x.abs().max(axis);\n    }\n    if (p === -Infinity) {\n      return x.abs().min(axis);\n    }\n    if (p === 'euclidean' || p === 2) {\n      // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2\n      return x.abs().pow(scalar(2, 'int32')).sum(axis).sqrt();\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n\n  // matrix (assumption axis[0] < axis[1])\n  if (Array.isArray(axis) && axis.length === 2) {\n    if (p === 1) {\n      return x.abs().sum(axis[0]).max(axis[1] - 1);\n    }\n    if (p === Infinity) {\n      return x.abs().sum(axis[1]).max(axis[0]);\n    }\n    if (p === -Infinity) {\n      return x.abs().sum(axis[1]).min(axis[0]);\n    }\n    if (p === 'fro' || p === 'euclidean') {\n      // norm(x) = sqrt(sum(pow(x, 2)))\n      return x.square().sum(axis).sqrt();\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n\n  throw new Error(`Error in norm: invalid axis: ${axis}`);\n}\n\nexport const norm = op({norm_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor1D, Tensor2D} from '../tensor';\nimport {convertToTensor, convertToTensorArray} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * @docalias (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D]\n */\nexport type LSTMCellFunc = {\n  (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D];\n};\n\n/**\n * Computes the next states and outputs of a stack of LSTMCells.\n *\n * Each cell output is used as input to the next cell.\n *\n * Returns `[cellState, cellOutput]`.\n *\n * Derived from tf.contrib.rn.MultiRNNCell.\n *\n * @param lstmCells Array of LSTMCell functions.\n * @param data The input to the cell.\n * @param c Array of previous cell states.\n * @param h Array of previous cell outputs.\n */\n/** @doc {heading: 'Operations', subheading: 'RNN'} */\nfunction multiRNNCell_(\n    lstmCells: LSTMCellFunc[], data: Tensor2D|TensorLike,\n    c: Array<Tensor2D|TensorLike>,\n    h: Array<Tensor2D|TensorLike>): [Tensor2D[], Tensor2D[]] {\n  const $data = convertToTensor(data, 'data', 'multiRNNCell');\n  const $c = convertToTensorArray(c, 'c', 'multiRNNCell');\n  const $h = convertToTensorArray(h, 'h', 'multiRNNCell');\n\n  let input = $data;\n  const newStates = [];\n  for (let i = 0; i < lstmCells.length; i++) {\n    const output = lstmCells[i](input, $c[i], $h[i]);\n    newStates.push(output[0]);\n    newStates.push(output[1]);\n    input = output[1];\n  }\n  const newC: Tensor2D[] = [];\n  const newH: Tensor2D[] = [];\n  for (let i = 0; i < newStates.length; i += 2) {\n    newC.push(newStates[i]);\n    newH.push(newStates[i + 1]);\n  }\n  return [newC, newH];\n}\n\n/**\n * Computes the next state and output of a BasicLSTMCell.\n *\n * Returns `[newC, newH]`.\n *\n * Derived from tf.contrib.rnn.BasicLSTMCell.\n *\n * @param forgetBias Forget bias for the cell.\n * @param lstmKernel The weights for the cell.\n * @param lstmBias The bias for the cell.\n * @param data The input to the cell.\n * @param c Previous cell state.\n * @param h Previous cell output.\n */\n/** @doc {heading: 'Operations', subheading: 'RNN'} */\nfunction basicLSTMCell_(\n    forgetBias: Scalar|TensorLike, lstmKernel: Tensor2D|TensorLike,\n    lstmBias: Tensor1D|TensorLike, data: Tensor2D|TensorLike,\n    c: Tensor2D|TensorLike, h: Tensor2D|TensorLike): [Tensor2D, Tensor2D] {\n  const $forgetBias =\n      convertToTensor(forgetBias, 'forgetBias', 'basicLSTMCell');\n  const $lstmKernel =\n      convertToTensor(lstmKernel, 'lstmKernel', 'basicLSTMCell');\n  const $lstmBias = convertToTensor(lstmBias, 'lstmBias', 'basicLSTMCell');\n  const $data = convertToTensor(data, 'data', 'basicLSTMCell');\n  const $c = convertToTensor(c, 'c', 'basicLSTMCell');\n  const $h = convertToTensor(h, 'h', 'basicLSTMCell');\n\n  const combined = $data.concat($h, 1);\n  const weighted = combined.matMul($lstmKernel);\n  const res: Tensor2D = weighted.add($lstmBias);\n\n  // i = input_gate, j = new_input, f = forget_gate, o = output_gate\n  const batchSize = res.shape[0];\n  const sliceCols = res.shape[1] / 4;\n  const sliceSize: [number, number] = [batchSize, sliceCols];\n  const i = res.slice([0, 0], sliceSize);\n  const j = res.slice([0, sliceCols], sliceSize);\n  const f = res.slice([0, sliceCols * 2], sliceSize);\n  const o = res.slice([0, sliceCols * 3], sliceSize);\n\n  const newC = i.sigmoid().mulStrict(j.tanh()).addStrict(\n      $c.mulStrict($forgetBias.add(f).sigmoid() as Tensor2D));\n  const newH = newC.tanh().mulStrict(o.sigmoid());\n  return [newC, newH];\n}\n\nexport const basicLSTMCell = op({basicLSTMCell_});\nexport const multiRNNCell = op({multiRNNCell_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor} from '../tensor';\nimport {assertTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {pow} from './binary_ops';\nimport {op} from './operation';\nimport {scalar} from './tensor_ops';\n\n/**\n * Compute the moving average of a variable.\n *\n * Without zeroDebias, the moving average operation is defined by:\n *   `v += delta`\n * where\n *   `delta = (1 - decay) * (x - v)`\n *\n * With zeroDebias (default), the `delta` term is scaled to debias the\n * effect of the (assumed) zero-initialization of `v`.\n *   `delta /= (1 - decay ^ step)`\n *\n * For more details on the zero-debiasing algorithm, see:\n *   https://arxiv.org/abs/1412.6980\n *\n * Note that this function is completely stateless and does not keep track of\n * step count. The step count needs to be maintained by the caller and passed\n * in as `step`.\n *\n * @param v The current moving average value.\n * @param x New input value, must have the same shape and dtype as `v`.\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\n * @param step Step count.\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\n * @returns The new moving average value.\n */\n/** @doc {heading: 'Operations', subheading: 'Moving Average'} */\nfunction movingAverage_<T extends Tensor>(\n    v: T|TensorLike, x: T|TensorLike, decay: number|Scalar,\n    step?: number|Scalar, zeroDebias = true): T {\n  const $v = convertToTensor(v, 'v', 'movingAverage');\n  const $x = convertToTensor(x, 'x', 'movingAverage');\n  const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n\n  assertTypesMatch($v, $x);\n  util.assert(\n      util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n\n  const one = scalar(1);\n  const oneMinusDecay = one.sub($decay);\n\n  let update = $x.sub($v).mul(oneMinusDecay);\n  if (zeroDebias) {\n    util.assert(\n        step != null, () => 'When using zeroDebias: true, step is required.');\n    const $step = convertToTensor(step, 'step', 'movingAverage');\n    update = update.div(one.sub(pow($decay, $step)));\n  }\n  return $v.add(update);\n}\n\nexport const movingAverage = op({movingAverage_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\nimport {slice} from './slice';\nimport {computeOutShape, maskToAxes, startForAxis, stopForAxis} from './slice_util';\n\n/**\n * Extracts a strided slice of a tensor.\n *\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\n * the given input tensor (x). Starting at the location specified by begin the\n * slice continues by adding stride to the index until all dimensions are not\n * less than end. Note that a stride can be negative, which causes a reverse\n * slice.\n *\n * ```js\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\n *    [3, 2, 3]);\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\n *                                                     // [4, 4, 4]]]\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\n *                                                     // [3, 3, 3]]]\n * ```\n *\n * @param x The tensor to stride slice.\n * @param begin The coordinates to start the slice from.\n * @param end: The coordinates to end the slice at.\n * @param strides: The size of the slice.\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param shrinkAxisMask: a bitmask where bit i implies that\n * the ith specification should shrink the dimensionality. begin and end must\n * imply a slice of size 1 in the dimension.\n */\n/** @doc {heading: 'Operations', subheading: 'Slicing and Joining'} */\nfunction stridedSlice_(\n    x: Tensor|TensorLike, begin: number[], end: number[], strides?: number[],\n    beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0,\n    shrinkAxisMask = 0): Tensor {\n  if (strides == null) {\n    strides = new Array(begin.length);\n  }\n  if (ellipsisMask !== 0) {\n    throw new Error('ellipsis mask is not yet supported');\n  }\n  let $x = convertToTensor(x, 'x', 'stridedSlice');\n\n  // Expand the dims of x based on the newAxisMask.\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = $x.shape.slice();\n  expandAxes.forEach(axis => {\n    begin[axis] = 0;\n    end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n  $x = $x.reshape(newShape);\n\n  // Normalize the start, end and strides.\n  for (let axis = 0; axis < $x.rank; axis++) {\n    begin[axis] = startForAxis(beginMask, begin, strides, $x.shape, axis);\n    end[axis] = stopForAxis(endMask, end, strides, $x.shape, axis);\n    strides[axis] = strides[axis] || 1;\n  }\n\n  const shrinkAxes = maskToAxes(shrinkAxisMask);\n  // Adjust the ends based on the shrink mask.\n  shrinkAxes.forEach(axis => {\n    end[axis] = begin[axis] + 1;\n    strides[axis] = 1;\n  });\n\n  // Figure out the output shape.\n  const size = computeOutShape(begin, end, strides);\n  // Remove the axes based on shrinkMask.\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n\n  const nonStrided = strides.every(v => v === 1);\n  if (nonStrided) {\n    return slice($x, begin, size).reshape(outShape);\n  }\n  const res = ENGINE.runKernel(\n      backend => backend.stridedSlice($x, begin, end, strides), {$x});\n  return res.reshape(outShape);\n}\n\nexport const stridedSlice = op({stridedSlice_});\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {NumericTensor, Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Finds the values and indices of the `k` largest entries along the last\n * dimension.\n *\n * If the input is a vector (rank=1), finds the k largest entries in the vector\n * and outputs their values and indices as vectors. Thus values[j] is the j-th\n * largest entry in input, and its index is indices[j].\n * For higher rank inputs, computes the top k entries along the last dimension.\n *\n * If two elements are equal, the lower-index element appears first.\n *\n * ```js\n * const a = tf.tensor2d([[1, 5], [4, 3]]);\n * const {values, indices} = tf.topk(a);\n * values.print();\n * indices.print();\n * ```\n * @param x 1-D or higher `tf.Tensor` with last dimension being at least `k`.\n * @param k Number of top elements to look for along the last dimension.\n * @param sorted If true, the resulting `k` elements will be sorted by the\n *     values in descending order.\n */\n/** @doc {heading: 'Operations', subheading: 'Evaluation'} */\nfunction topk_<T extends Tensor>(\n    x: T|TensorLike, k = 1, sorted = true): {values: T, indices: T} {\n  const $x = convertToTensor(x, 'x', 'topk');\n  if ($x.rank === 0) {\n    throw new Error('topk() expects the input to be of rank 1 or higher');\n  }\n  const lastDim = $x.shape[$x.shape.length - 1];\n  if (k > lastDim) {\n    throw new Error(\n        `'k' passed to topk() must be <= the last dimension (${lastDim}) ` +\n        `but got ${k}`);\n  }\n\n  const [values, indices] =\n      ENGINE.runKernel(b => b.topk($x as NumericTensor, k, sorted), {$x});\n  return {values, indices} as {values: T, indices: T};\n}\n\nexport const topk = op({topk_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, ShapeMap, TensorLike} from '../types';\nimport {op} from './operation';\nimport * as scatter_nd_util from './scatter_nd_util';\n\n/**\n * Creates a new tensor by applying sparse updates to individual\n * values or slices within a zero tensor of the given shape tensor according to\n * indices. This operator is the inverse of the `tf.gatherND` operator which\n * extracts values or slices from a given tensor.\n *\n * ```js\n * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\n * const updates = tf.tensor1d([9, 10, 11, 12]);\n * const shape = [8];\n * tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]\n * ```\n *\n * @param indices The tensor contains the indices into the output tensor.\n * @param updates The tensor contains the value for the indices.\n * @param shape: The shape of the output tensor.\n */\n/** @doc {heading: 'Operations', subheading: 'Slicing and Joining'} */\nfunction scatterND_<R extends Rank>(\n    indices: Tensor|TensorLike, updates: Tensor|TensorLike,\n    shape: ShapeMap[R]): Tensor<R> {\n  const $indices = convertToTensor(indices, 'indices', 'scatterND', 'int32');\n  const $updates = convertToTensor(updates, 'updates', 'scatterND');\n  scatter_nd_util.validateInput($updates, $indices, shape);\n\n  return ENGINE.runKernel(\n      backend => backend.scatterND($indices, $updates, shape),\n      {$indices, $updates});\n}\n\nexport const scatterND = op({scatterND_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {complex, imag, real} from '../ops/complex_ops';\nimport {op} from '../ops/operation';\nimport {Tensor, Tensor2D} from '../tensor';\nimport {assert} from '../util';\nimport {scalar, zeros} from './tensor_ops';\n\n/**\n * Fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the inner-most\n * dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.fft().print();  // tf.spectral.fft(x).print();\n * ```\n * @param input The complex input to compute an fft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction fft_(input: Tensor): Tensor {\n  assert(\n      input.dtype === 'complex64',\n      () => `The dtype for tf.spectral.fft() must be complex64 ` +\n          `but got ${input.dtype}.`);\n\n  // Collapse all outer dimensions to a single batch dimension.\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  const input2D = input.as2D(batch, innerDimensionSize);\n\n  const ret = ENGINE.runKernel(backend => backend.fft(input2D), {input});\n\n  return ret.reshape(input.shape);\n}\n\n/**\n * Inverse fast Fourier transform.\n *\n * Computes the inverse 1-dimensional discrete Fourier transform over the\n * inner-most dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.ifft().print();  // tf.spectral.ifft(x).print();\n * ```\n * @param input The complex input to compute an ifft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction ifft_(input: Tensor): Tensor {\n  assert(\n      input.dtype === 'complex64',\n      () => `The dtype for tf.spectral.ifft() must be complex64 ` +\n          `but got ${input.dtype}.`);\n\n  // Collapse all outer dimensions to a single batch dimension.\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  const input2D = input.as2D(batch, innerDimensionSize);\n\n  const ret = ENGINE.runKernel(backend => backend.ifft(input2D), {input});\n\n  return ret.reshape(input.shape);\n}\n\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input: Tensor, fftLength?: number): Tensor {\n  assert(\n      input.dtype === 'float32',\n      () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n\n  let adjustedInput: Tensor;\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = input.slice(begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = input.concat(zeros(zerosShape), input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  }\n\n  // Complement the input with zero imaginary numbers.\n  const zerosInput = adjustedInput.zerosLike();\n  const complexInput =\n      complex(adjustedInput, zerosInput).as2D(batch, innerDimensionSize);\n\n  const ret = fft(complexInput);\n\n  // Exclude complex conjugations. These conjugations are put symmetrically.\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = realValues.split(\n      [half, innerDimensionSize - half], realValues.shape.length - 1);\n  const imagComplexConjugate = imagValues.split(\n      [half, innerDimensionSize - half], imagValues.shape.length - 1);\n\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n\n  return complex(realComplexConjugate[0], imagComplexConjugate[0])\n      .reshape(outputShape);\n}\n\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction irfft_(input: Tensor): Tensor {\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n\n  if (innerDimensionSize <= 2) {\n    const complexInput = input.as2D(batch, innerDimensionSize);\n    const ret = ifft(complexInput);\n    return real(ret);\n  } else {\n    // The length of unique components of the DFT of a real-valued signal\n    // is 2 * (input_len - 1)\n    const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n    const realInput = real(input).as2D(batch, innerDimensionSize);\n    const imagInput = imag(input).as2D(batch, innerDimensionSize);\n\n    const realConjugate =\n        realInput.slice([0, 1], [batch, innerDimensionSize - 2]).reverse(1);\n    const imagConjugate: Tensor2D =\n        imagInput.slice([0, 1], [batch, innerDimensionSize - 2])\n            .reverse(1)\n            .mul(scalar(-1));\n\n    const r = realInput.concat(realConjugate, 1);\n    const i = imagInput.concat(imagConjugate, 1);\n    const complexInput = complex(r, i).as2D(outputShape[0], outputShape[1]);\n    const ret = ifft(complexInput);\n    return real(ret);\n  }\n}\n\nexport const fft = op({fft_});\nexport const ifft = op({ifft_});\nexport const rfft = op({rfft_});\nexport const irfft = op({irfft_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport {Scalar, Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, ScalarLike, ShapeMap, TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Converts a sparse representation into a dense tensor.\n *\n * Builds an array dense with shape outputShape such that:\n *\n * // If sparseIndices is scalar\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\n *\n * // If sparseIndices is a vector, then for each i\n * dense[sparseIndices[i]] = sparseValues[i]\n *\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\n * All other values in dense are set to defaultValue. If sparseValues is a\n * scalar, all sparse indices are set to this single value.\n *\n * If indices are repeated the final value is summed over all values for those\n * indices.\n *\n * ```js\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\n * const shape = [8];\n * tf.sparseToDense(indices, values, shape).print();\n * ```\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape Shape of the dense output tensor. the type is inferred.\n * @param defaultValue Scalar. Value to set for indices not specified in\n * sparseIndices. Defaults to zero.\n */\n/** @doc {heading: 'Operations', subheading: 'Normalization'} */\nfunction sparseToDense_<R extends Rank>(\n    sparseIndices: Tensor|TensorLike, sparseValues: Tensor|TensorLike,\n    outputShape: ShapeMap[R], defaultValue: Scalar|ScalarLike = 0): Tensor<R> {\n  const $sparseIndices =\n      convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n  const $sparseValues =\n      convertToTensor(sparseValues, 'sparseValues', 'sparseToDense');\n  const $defaultValue = convertToTensor(\n      defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n\n  sparse_to_dense.validateInput(\n      $sparseIndices, $sparseValues, outputShape, $defaultValue);\n\n  return ENGINE.runKernel(\n      backend => backend.sparseToDense(\n          $sparseIndices, $sparseValues, outputShape, $defaultValue),\n      {$sparseIndices, $sparseValues, $defaultValue});\n}\n\nexport const sparseToDense = op({sparseToDense_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../tensor';\n\n/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(\n    sparseIndices: Tensor, sparseValues: Tensor, outputShape: number[],\n    defaultValues: Tensor) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error(\n        'tf.sparseToDense() expects the indices to be int32 type,' +\n        ` but the dtype was ${sparseIndices.dtype}.`);\n  }\n  if (sparseIndices.rank > 2) {\n    throw new Error(\n        'sparseIndices should be a scalar, vector, or matrix,' +\n        ` but got shape ${sparseIndices.shape}.`);\n  }\n\n  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error(\n        'outputShape has incorrect number of elements:,' +\n        ` ${outputShape.length}, should be: ${numDims}.`);\n  }\n\n  const numValues = sparseValues.size;\n  if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error(\n        'sparseValues has incorrect shape ' +\n        `${sparseValues.shape}, should be [] or [${numElems}]`);\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Gather slices from input tensor into a Tensor with shape specified by\n * `indices`.\n *\n * `indices` is an K-dimensional integer tensor, best thought of as a\n * (K-1)-dimensional tensor of indices into input, where each element defines a\n * slice of input:\n * output[\\\\(i_0, ..., i_{K-2}\\\\)] = input[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n *\n * Whereas in `tf.gather`, `indices` defines slices into the first dimension of\n * input, in `tf.gatherND`, `indices` defines slices into the first N dimensions\n * of input, where N = indices.shape[-1].\n *\n * The last dimension of indices can be at most the rank of input:\n * indices.shape[-1] <= input.rank\n *\n * The last dimension of `indices` corresponds to elements\n * (if indices.shape[-1] == input.rank) or slices\n * (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of\n * input.\n * The output tensor has shape\n * indices.shape[:-1] + input.shape[indices.shape[-1]:]\n *\n * Note that on CPU, if an out of bound index is found, an error is returned. On\n * GPU, if an out of bound index is found, a 0 is stored in the corresponding\n * output value.\n *\n * ```js\n * const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');\n * const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);\n * tf.gatherND(input, indices).print() // [10, 11]\n * ```\n *\n * @param x The tensor from which to gather values.\n * @param indices Index tensor, must be of type int32.\n */\n/** @doc {heading: 'Operations', subheading: 'Slicing and Joining'} */\nfunction gatherND_(x: Tensor|TensorLike, indices: Tensor|TensorLike): Tensor {\n  const $indices = convertToTensor(indices, 'indices', 'gatherND', 'int32');\n  const $x = convertToTensor(x, 'x', 'gatherND');\n  return ENGINE.runKernel(\n      backend => backend.gatherND($x, $indices), {$x, $indices});\n}\nexport const gatherND = op({gatherND_});\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {op} from './operation';\n\n/**\n * Returns a diagonal tensor with a given diagonal values.\n *\n * Given a diagonal, this operation returns a tensor with the diagonal and\n * everything else padded with zeros.\n *\n * Assume the input has dimensions `[D1,..., Dk]`, then the output is a tensor\n * of rank 2k with dimensions `[D1,..., Dk, D1,..., Dk]`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * tf.diag(x).print()\n * ```\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4, 5, 6, 6, 8], [4, 2])\n *\n * tf.diag(x).print()\n * ```\n * @param x The input tensor.\n */\nfunction diag_(x: Tensor): Tensor {\n  const $x = convertToTensor(x, 'x', 'diag').flatten();\n  const outShape = [...x.shape, ...x.shape];\n  return ENGINE.runKernel(backend => backend.diag($x), {$x}).reshape(outShape);\n}\n\nexport const diag = op({diag_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {randomUniform} from './array_ops';\nimport {getNoiseShape} from './dropout_util';\nimport {op} from './operation';\n\n/**\n * Computes dropout.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 2, 1]);\n * const rate = 0.75;\n * const output = tf.dropout(x, rate);\n * output.print();\n * ```\n *\n * @param x A floating point Tensor or TensorLike.\n * @param rate A float in the range [0, 1). The probability that each element\n *   of x is discarded.\n * @param noiseShape An array of numbers of type int32, representing the\n * shape for randomly generated keep/drop flags. If the noiseShape has null\n * value, it will be automatically replaced with the x's relative dimension\n * size. Optional.\n * @param seed Used to create random seeds. Optional.\n * @returns A Tensor of the same shape of x.\n */\n/** @doc {heading: 'Operations', subheading: 'Dropout'} */\nfunction dropout_(\n    x: Tensor|TensorLike, rate: number, noiseShape?: number[],\n    seed?: number|string): Tensor {\n  const $x = convertToTensor(x, 'x', 'dropout');\n\n  util.assert(\n      $x.dtype === 'float32',\n      () => `x has to be a floating point tensor since it's going to be ` +\n          `scaled, but got a ${$x.dtype} tensor instead.`);\n  util.assert(\n      rate >= 0 && rate < 1,\n      () => `rate must be a float in the range [0, 1), but got ${rate}.`);\n\n  if (rate === 0) {\n    return x instanceof Tensor ? $x.clone() : $x;\n  }\n\n  const $noiseShape = getNoiseShape($x, noiseShape);\n  const keepProb = 1 - rate;\n  const multiplier = randomUniform($noiseShape, 0, 1, 'float32', seed)\n                         .add(keepProb)\n                         .floor()\n                         .div(keepProb);\n\n  return $x.mul(multiplier);\n}\n\nexport const dropout = op({dropout_});\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport * as util from '../util';\n\n/**\n * Normalize noise shape based on provided tensor and noise shape.\n *\n * @param x Tensor.\n * @param noiseShape The shape for the randomly generated keep/drop flags, as\n *   an array of numbers. Optional.\n * @returns Normalized noise shape.\n */\nexport function getNoiseShape(x: Tensor, noiseShape?: number[]): number[] {\n  if (noiseShape == null) {\n    return x.shape.slice();\n  }\n  if (util.arraysEqual(x.shape, noiseShape)) {\n    return noiseShape;\n  }\n  if (x.shape.length === noiseShape.length) {\n    const newDimension: number[] = [];\n    for (let i = 0; i < x.shape.length; i++) {\n      if (noiseShape[i] == null && x.shape[i] != null) {\n        newDimension.push(x.shape[i]);\n      } else {\n        newDimension.push(noiseShape[i]);\n      }\n    }\n    return newDimension;\n  }\n\n  return noiseShape;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {op} from '../ops/operation';\nimport {Tensor, Tensor1D} from '../tensor';\n\nimport {mul} from './binary_ops';\nimport {concat} from './concat_split';\nimport {slice} from './slice';\nimport {rfft} from './spectral_ops';\nimport {fill, tensor1d, tensor2d} from './tensor_ops';\n\n/**\n * Generate a Hann window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hannWindow(10).print();\n * ```\n * @param The length of window\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hannWindow_(windowLength: number): Tensor1D {\n  return cosineWindow(windowLength, 0.5, 0.5);\n}\n\n/**\n * Generate a hamming window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hammingWindow(10).print();\n * ```\n * @param The length of window\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hammingWindow_(windowLength: number): Tensor1D {\n  return cosineWindow(windowLength, 0.54, 0.46);\n}\n\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue An number to use where the input signal does\n *     not exist when padEnd is True.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction frame_(\n    signal: Tensor1D, frameLength: number, frameStep: number, padEnd = false,\n    padValue = 0): Tensor {\n  let start = 0;\n  const output: Tensor[] = [];\n  while (start + frameLength <= signal.size) {\n    output.push(slice(signal, start, frameLength));\n    start += frameStep;\n  }\n\n  if (padEnd) {\n    while (start < signal.size) {\n      const padLen = (start + frameLength) - signal.size;\n      const pad = concat(\n          [slice(signal, start, frameLength - padLen),\n           fill([padLen], padValue)]);\n      output.push(pad);\n      start += frameStep;\n    }\n  }\n\n  if (output.length === 0) {\n    return tensor2d([], [0, frameLength]);\n  }\n\n  return concat(output).as2D(output.length, frameLength);\n}\n\n/**\n * Computes the Short-time Fourier Transform of signals\n * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform\n *\n * ```js\n * const input = tf.tensor1d([1, 1, 1, 1, 1])\n * tf.signal.stft(input, 3, 1).print();\n * ```\n * @param signal 1-dimensional real value tensor.\n * @param frameLength The window length of samples.\n * @param frameStep The number of samples to step.\n * @param fftLength The size of the FFT to apply.\n * @param windowFn A callable that takes a window length and returns 1-d tensor.\n */\n/**\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction stft_(\n    signal: Tensor1D, frameLength: number, frameStep: number,\n    fftLength?: number,\n    windowFn: (length: number) => Tensor1D = hannWindow): Tensor {\n  if (fftLength == null) {\n    fftLength = enclosingPowerOfTwo(frameLength);\n  }\n  const framedSignal = frame(signal, frameLength, frameStep);\n  const windowedSignal = mul(framedSignal, windowFn(frameLength));\n  const output: Tensor[] = [];\n  for (let i = 0; i < framedSignal.shape[0]; i++) {\n    output.push(rfft(windowedSignal.slice([i, 0], [1, frameLength]),\n      fftLength));\n  }\n  return concat(output);\n}\n\nfunction enclosingPowerOfTwo(value: number) {\n  // Return 2**N for integer N such that 2**N >= value.\n  return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));\n}\n\nfunction cosineWindow(windowLength: number, a: number, b: number): Tensor1D {\n  const even = 1 - windowLength % 2;\n  const newValues = new Float32Array(windowLength);\n  for (let i = 0; i < windowLength; ++i) {\n    const cosArg = (2.0 * Math.PI * i) / (windowLength + even - 1);\n    newValues[i] = a - b * Math.cos(cosArg);\n  }\n  return tensor1d(newValues, 'float32');\n}\n\nexport const hannWindow = op({hannWindow_});\nexport const hammingWindow = op({hammingWindow_});\nexport const frame = op({frame_});\nexport const stft = op({stft_});\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert, assertShapesMatch, getTypedArrayFromDType} from '../util';\nimport {tensor} from './tensor_ops';\n\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Evaluation'} */\nasync function inTopKAsync_<T extends Tensor, U extends Tensor>(\n    predictions: T|TensorLike, targets: U|TensorLike, k = 1): Promise<U> {\n  const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n  const $targets = convertToTensor(targets, 'targets', 'inTopK');\n\n  assert(\n      $predictions.rank > 1,\n      () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n          `but got ${$predictions.rank}`);\n  assert(\n      $predictions.rank - 1 === $targets.rank,\n      () => `predictions rank should be 1 larger than ` +\n          `targets rank, but got predictions rank ` +\n          `${$predictions.rank} and targets rank ${$targets.rank}`);\n  assertShapesMatch(\n      $predictions.shape.slice(0, $predictions.shape.length - 1),\n      $targets.shape,\n      `predictions's shape should be align with the targets' shape, ` +\n          'except the last dimension.');\n  const lastDim = $predictions.shape[$predictions.shape.length - 1];\n  assert(\n      k > 0 && k <= lastDim,\n      () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n          `dimension (${lastDim}), but got ${k}`);\n\n  const predictionsVals = await $predictions.data();\n  const targetsVals = await $targets.data();\n\n  // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n  // and look up topK along lastDim.\n  const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n  const precision = getTypedArrayFromDType('bool', batch);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = predictionsVals.subarray(offset, offset + size);\n    const valAndInd: Array<{value: number, index: number}> = [];\n    for (let i = 0; i < vals.length; i++) {\n      valAndInd.push({value: vals[i], index: i});\n    }\n    valAndInd.sort((a, b) => b.value - a.value);\n\n    precision[b] = 0;\n    for (let i = 0; i < k; i++) {\n      if (valAndInd[i].index === targetsVals[b]) {\n        precision[b] = 1;\n        break;\n      }\n    }\n  }\n\n  if (predictions !== $predictions) {\n    $predictions.dispose();\n  }\n  if (targets !== $targets) {\n    $targets.dispose();\n  }\n\n  // Output precision has the same shape as targets.\n  return tensor(precision, $targets.shape, 'bool') as U;\n}\n\nexport const inTopKAsync = inTopKAsync_;\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {customGrad} from '../gradients';\nimport {Tensor} from '../tensor';\nimport {GradSaveFunc} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assertShapesMatch} from '../util';\nimport {expandShapeToKeepDim} from './axis_util';\nimport {minimum} from './binary_ops';\nimport {op} from './operation';\nimport {ones, scalar} from './tensor_ops';\n\nexport enum Reduction {\n  NONE,\n  MEAN,\n  SUM,\n  SUM_BY_NONZERO_WEIGHTS\n}\n\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ... dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n */\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\nfunction computeWeightedLoss_<T extends Tensor, O extends Tensor>(\n    losses: T|TensorLike, weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n  }\n\n  const weightedLoss = ($weights == null) ? $losses : $losses.mul($weights);\n\n  if (reduction === Reduction.NONE) {\n    return weightedLoss as O;\n  }\n  if (reduction === Reduction.SUM) {\n    return weightedLoss.sum();\n  }\n  if (reduction === Reduction.MEAN) {\n    if ($weights == null) {\n      return weightedLoss.mean();\n    } else {\n      const broadcastFactor = $losses.size / $weights.size;\n      const result = weightedLoss.sum().div($weights.sum());\n      return broadcastFactor > 1 ? result.div(scalar(broadcastFactor)) :\n                                   result as O;\n    }\n  }\n  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if ($weights == null) {\n      return weightedLoss.sum().div(scalar($losses.size));\n    } else {\n      const broadcastedWeights = $weights.mul(ones($losses.shape));\n\n      const numNonZeros =\n          broadcastedWeights.notEqual(scalar(0)).sum().toFloat();\n      return weightedLoss.sum().div(numNonZeros);\n    }\n  }\n\n  throw Error(`Unknown reduction: ${reduction}`);\n}\n\n/**\n * Computes the absolute difference loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n */\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\nfunction absoluteDifference_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'absoluteDifference');\n  const $predictions =\n      convertToTensor(predictions, 'predictions', 'absoluteDifference');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'absoluteDifference');\n  }\n  assertShapesMatch(\n      $labels.shape, $predictions.shape, 'Error in absoluteDifference: ');\n\n  const losses = $labels.sub($predictions).abs();\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\n/**\n * Computes the mean squared error between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n */\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\nfunction meanSquaredError_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'meanSquaredError');\n  const $predictions =\n      convertToTensor(predictions, 'predictions', 'meanSquaredError');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'meanSquaredError');\n  }\n  assertShapesMatch(\n      $labels.shape, $predictions.shape, 'Error in meanSquaredError: ');\n\n  const losses = $labels.squaredDifference($predictions);\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\n/**\n * Computes the cosine distance loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param axis The dimension along which the cosine distance is computed.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n */\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\nfunction cosineDistance_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike, axis: number,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'cosineDistance');\n  const $predictions =\n      convertToTensor(predictions, 'predictions', 'cosineDistance');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'cosineDistance');\n  }\n  assertShapesMatch(\n      $labels.shape, $predictions.shape, 'Error in cosineDistance: ');\n\n  const one = scalar(1);\n  const losses = one.sub($labels.mul($predictions).sum(axis, true));\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\n/**\n * Computes the Hinge loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n */\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\nfunction hingeLoss_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  let $labels = convertToTensor(labels, 'labels', 'hingeLoss');\n  const $predictions = convertToTensor(predictions, 'predictions', 'hingeLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'hingeLoss');\n  }\n  assertShapesMatch($labels.shape, $predictions.shape, 'Error in hingeLoss: ');\n\n  const one = scalar(1);\n  // Convert binary labels to (-1, 1)\n  $labels = scalar(2).mul($labels).sub(one);\n  const losses = one.sub($labels.mul($predictions)).relu();\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\n/**\n * Computes the log loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param epsilon A small increment to avoid taking log of zero\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n */\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\nfunction logLoss_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike, epsilon = 1e-7,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'logLoss');\n  const $predictions = convertToTensor(predictions, 'predictions', 'logLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'logLoss');\n  }\n  assertShapesMatch($labels.shape, $predictions.shape, 'Error in logLoss: ');\n\n  const one = scalar(1);\n  const epsilonScalar = scalar(epsilon);\n  const losses = $labels.mul($predictions.add(epsilonScalar).log())\n                     .neg()\n                     .sub(one.sub($labels).mul(\n                         one.sub($predictions).add(epsilonScalar).log()));\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\nfunction sigmoidCrossEntropyWithLogits_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, logits: T|TensorLike): O {\n  const $labels =\n      convertToTensor(labels, 'labels', 'sigmoidCrossEntropyWithLogits');\n  const $logits =\n      convertToTensor(logits, 'logits', 'sigmoidCrossEntropyWithLogits');\n  assertShapesMatch(\n      $labels.shape, $logits.shape, 'Error in sigmoidCrossEntropyWithLogits: ');\n\n  /**\n   * Implementation Details:\n   *\n   * For brevity, let `x = logits`, `z = labels`.  The logistic loss is\n   *     z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))\n   *   = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))\n   *   = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))\n   *   = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))\n   *   = (1 - z) * x + log(1 + exp(-x))\n   *   = x - x * z + log(1 + exp(-x))\n   *\n   *   For x < 0, to avoid overflow in exp(-x), we reformulate the above\n   *     x - x * z + log(1 + exp(-x))\n   *   = log(exp(x)) - x * z + log(1 + exp(-x))\n   *   = - x * z + log(1 + exp(x))\n   *\n   * Hence, to ensure stability and avoid overflow, the implementation uses\n   * this equivalent formulation:\n   *     max(x, 0) - x * z + log(1 + exp(-abs(x)))\n   */\n  const maxOutput = $logits.relu();\n  const outputXTarget = $logits.mul($labels);\n  const sigmoidOutput = $logits.abs().neg().exp().log1p();\n\n  return maxOutput.sub(outputXTarget).add(sigmoidOutput);\n}\n\n/**\n * Computes the sigmoid cross entropy loss between two tensors.\n *\n * If labelSmoothing is nonzero, smooth the labels towards 1/2:\n *\n *   newMulticlassLabels = multiclassLabels * (1 - labelSmoothing)\n *                         + 0.5 * labelSmoothing\n *\n * @param multiClassLabels The ground truth output tensor of shape\n * [batch_size, num_classes], same dimensions as 'predictions'.\n * @param logits The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param labelSmoothing If greater than 0, then smooth the labels.\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n */\n/** @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' } */\nfunction sigmoidCrossEntropy_<T extends Tensor, O extends Tensor>(\n    multiClassLabels: T|TensorLike, logits: T|TensorLike,\n    weights?: Tensor|TensorLike, labelSmoothing = 0,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  let $multiClassLabels = convertToTensor(\n      multiClassLabels, 'multiClassLabels', 'sigmoidCrossEntropy');\n  const $logits = convertToTensor(logits, 'logits', 'sigmoidCrossEntropy');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'sigmoidCrossEntropy');\n  }\n  assertShapesMatch(\n      $multiClassLabels.shape, $logits.shape, 'Error in sigmoidCrossEntropy: ');\n\n  if (labelSmoothing > 0) {\n    const labelSmoothingScalar = scalar(labelSmoothing);\n    const one = scalar(1);\n    const half = scalar(0.5);\n\n    $multiClassLabels = $multiClassLabels.mul(one.sub(labelSmoothingScalar))\n                            .add(half.mul(labelSmoothingScalar));\n  }\n  const losses = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);\n\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\n/**\n * Computes the huber loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param delta Point where huber loss changes from quadratic to linear.\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`.\n */\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\nfunction huberLoss_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike, delta = 1.0,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'huberLoss');\n  const $predictions = convertToTensor(predictions, 'predictions', 'huberLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'huberLoss');\n  }\n  assertShapesMatch($labels.shape, $predictions.shape, 'Error in huberLoss: ');\n\n  const deltaScalar = scalar(delta);\n  const error = $predictions.sub($labels).abs();\n  const quadratic = minimum(error, deltaScalar);\n  const linear = error.sub(quadratic);\n\n  const losses =\n      scalar(0.5).mul(quadratic.square()).add(deltaScalar.mul(linear));\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\n/**\n * Computes softmax cross entropy between logits and labels.\n *\n * Measures the probability error in discrete classification tasks in which\n * the classes are mutually exclusive (each entry is in exactly one class).\n * For example, each CIFAR-10 image is labeled with one and only one label: an\n * image can be a dog or a truck, but not both.\n *\n * `NOTE`: While the classes are mutually exclusive, their probabilities need\n * not be. All that is required is that each row of labels is a valid\n * probability distribution. If they are not, the computation of the gradient\n * will be incorrect.\n *\n * `WARNING`: This op expects unscaled logits, since it performs a softmax on\n * logits internally for efficiency. Do not call this op with the output of\n * softmax, as it will produce incorrect results.\n *\n * logits and labels must have the same shape, e.g. [batch_size, num_classes]\n * and the same dtype.\n * @param labels The labels array.\n * @param logits The logits array.\n * @param dim The dimension softmax would be performed on. Defaults to `-1`\n *     which indicates the last dimension.\n */\nfunction softmaxCrossEntropyWithLogits_<T extends Tensor, O extends Tensor>(\n    labels: T, logits: T, dim = -1): O {\n  if (dim === -1) {\n    dim = logits.rank - 1;\n  }\n\n  if (dim !== logits.rank - 1) {\n    throw Error(\n        `Softmax cross entropy along a non-last dimension is not yet ` +\n        `supported. Labels / logits was rank ${logits.rank} ` +\n        `and dim was ${dim}`);\n  }\n  // Use a custom gradient for numerical stability.\n  const customOp =\n      customGrad((labels: Tensor, logits: Tensor, save: GradSaveFunc) => {\n        // Reference:\n        //   1. http://cs231n.github.io/linear-classify/#softmax\n        //   2. https://blog.feedly.com/tricks-of-the-trade-logsumexp/\n        const keepDims = true;\n        const lse = logits.logSumExp([dim], keepDims);\n        const logResult = logits.toFloat().sub(lse);\n        save([labels, logResult]);\n\n        const costVector = logResult.mul(labels).neg();\n        const value: O = costVector.sum([dim]);\n\n        const gradFunc = (dy: O, saved: Tensor[]) => {\n          const [labels, logResult] = saved;\n          const dyShape = expandShapeToKeepDim(dy.shape, [dim]);\n          return [\n            dy.reshape(dyShape).mul(labels.toFloat().sub(logResult.exp())),\n            dy.reshape(dyShape).mul(logResult.exp().sub(labels.toFloat())),\n          ];\n        };\n        return {value, gradFunc};\n      });\n\n  return customOp(labels, logits);\n}\n\n/**\n * Computes the softmax cross entropy loss between two tensors.\n *\n * If labelSmoothing is nonzero, smooth the labels towards 1/2:\n *\n *   newOnehotLabels = onehotLabels * (1 - labelSmoothing)\n *                         + labelSmoothing / numClasses\n *\n * @param onehotLabels One hot encoded labels\n *    [batch_size, num_classes], same dimensions as 'predictions'.\n * @param logits The predicted outputs.\n * @param weights Tensor whose rank is either 0, or 1, and must be\n *    broadcastable to `loss`  of shape [batch_size]\n * @param labelSmoothing If greater than 0, then smooth the labels.\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n */\n/** @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' } */\nfunction softmaxCrossEntropy_<T extends Tensor, O extends Tensor>(\n    onehotLabels: T|TensorLike, logits: T|TensorLike,\n    weights?: Tensor|TensorLike, labelSmoothing = 0,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  let $onehotLabels =\n      convertToTensor(onehotLabels, 'onehotLabels', 'softmaxCrossEntropy');\n  const $logits = convertToTensor(logits, 'logits', 'softmaxCrossEntropy');\n  let $weights: Tensor = null;\n\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'softmaxCrossEntropy');\n  }\n\n  assertShapesMatch(\n      $onehotLabels.shape, $logits.shape, 'Error in softmaxCrossEntropy: ');\n\n  if (labelSmoothing > 0) {\n    const labelSmoothingScalar = scalar(labelSmoothing);\n    const one = scalar(1);\n    const numClasses = scalar($onehotLabels.shape[1]);\n\n    $onehotLabels = $onehotLabels.mul(one.sub(labelSmoothingScalar))\n                        .add(labelSmoothingScalar.div(numClasses));\n  }\n\n  const losses = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);\n\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\nexport const absoluteDifference = op({absoluteDifference_});\nexport const computeWeightedLoss = op({computeWeightedLoss_});\nexport const cosineDistance = op({cosineDistance_});\nexport const hingeLoss = op({hingeLoss_});\nexport const huberLoss = op({huberLoss_});\nexport const logLoss = op({logLoss_});\nexport const meanSquaredError = op({meanSquaredError_});\nexport const sigmoidCrossEntropy = op({sigmoidCrossEntropy_});\nexport const softmaxCrossEntropy = op({softmaxCrossEntropy_});\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Linear algebra ops.\n */\n\nimport {ENGINE} from '../engine';\nimport {dispose} from '../globals';\nimport {Tensor, Tensor1D, Tensor2D} from '../tensor';\nimport {assert} from '../util';\nimport {eye, squeeze, stack, unstack} from './array_ops';\nimport {split} from './concat_split';\nimport {norm} from './norm';\nimport {op} from './operation';\nimport {sum} from './reduction_ops';\nimport {tensor2d} from './tensor_ops';\n\n/**\n * Gram-Schmidt orthogonalization.\n *\n * ```js\n * const x = tf.tensor2d([[1, 2], [3, 4]]);\n * let y = tf.linalg.gramSchmidt(x);\n * y.print();\n * console.log('Othogonalized:');\n * y.dot(y.transpose()).print();  // should be nearly the identity matrix.\n * console.log('First row direction maintained:');\n * const data = await y.array();\n * console.log(data[0][1] / data[0][0]);  // should be nearly 2.\n * ```\n *\n * @param xs The vectors to be orthogonalized, in one of the two following\n *   formats:\n *   - An Array of `tf.Tensor1D`.\n *   - A `tf.Tensor2D`, i.e., a matrix, in which case the vectors are the rows\n *     of `xs`.\n *   In each case, all the vectors must have the same length and the length\n *   must be greater than or equal to the number of vectors.\n * @returns The orthogonalized and normalized vectors or matrix.\n *   Orthogonalization means that the vectors or the rows of the matrix\n *   are orthogonal (zero inner products). Normalization means that each\n *   vector or each row of the matrix has an L2 norm that equals `1`.\n */\n/**\n * @doc {heading:'Operations',\n *       subheading:'Linear Algebra',\n *       namespace:'linalg'}\n */\nfunction gramSchmidt_(xs: Tensor1D[]|Tensor2D): Tensor1D[]|Tensor2D {\n  let inputIsTensor2D: boolean;\n  if (Array.isArray(xs)) {\n    inputIsTensor2D = false;\n    assert(\n        xs != null && xs.length > 0,\n        () => 'Gram-Schmidt process: input must not be null, undefined, or ' +\n            'empty');\n    const dim = xs[0].shape[0];\n    for (let i = 1; i < xs.length; ++i) {\n      assert(\n          xs[i].shape[0] === dim,\n          () =>\n              'Gram-Schmidt: Non-unique lengths found in the input vectors: ' +\n              `(${(xs as Tensor1D[])[i].shape[0]} vs. ${dim})`);\n    }\n  } else {\n    inputIsTensor2D = true;\n    xs = split(xs, xs.shape[0], 0).map(x => squeeze(x, [0]));\n  }\n\n  assert(\n      xs.length <= xs[0].shape[0],\n      () => `Gram-Schmidt: Number of vectors (${\n                (xs as Tensor1D[]).length}) exceeds ` +\n          `number of dimensions (${(xs as Tensor1D[])[0].shape[0]}).`);\n\n  const ys: Tensor1D[] = [];\n  const xs1d = xs;\n  for (let i = 0; i < xs.length; ++i) {\n    ys.push(ENGINE.tidy(() => {\n      let x = xs1d[i];\n      if (i > 0) {\n        for (let j = 0; j < i; ++j) {\n          const proj = sum(ys[j].mulStrict(x)).mul(ys[j]);\n          x = x.sub(proj);\n        }\n      }\n      return x.div(norm(x, 'euclidean'));\n    }));\n  }\n\n  if (inputIsTensor2D) {\n    return stack(ys, 0) as Tensor2D;\n  } else {\n    return ys;\n  }\n}\n\n/**\n * Compute QR decomposition of m-by-n matrix using Householder transformation.\n *\n * Implementation based on\n *   [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf]\n * (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)\n *\n * ```js\n * const a = tf.tensor2d([[1, 2], [3, 4]]);\n * let [q, r] = tf.linalg.qr(a);\n * console.log('Q');\n * q.print();\n * console.log('R');\n * r.print();\n * console.log('Orthogonalized');\n * q.dot(q.transpose()).print()  // should be nearly the identity matrix.\n * console.log('Reconstructed');\n * q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];\n * ```\n *\n * @param x The `tf.Tensor` to be QR-decomposed. Must have rank >= 2. Suppose\n *   it has the shape `[..., M, N]`.\n * @param fullMatrices An optional boolean parameter. Defaults to `false`.\n *   If `true`, compute full-sized `Q`. If `false` (the default),\n *   compute only the leading N columns of `Q` and `R`.\n * @returns An `Array` of two `tf.Tensor`s: `[Q, R]`. `Q` is a unitary matrix,\n *   i.e., its columns all have unit norm and are mutually orthogonal.\n *   If `M >= N`,\n *     If `fullMatrices` is `false` (default),\n *       - `Q` has a shape of `[..., M, N]`,\n *       - `R` has a shape of `[..., N, N]`.\n *     If `fullMatrices` is `true` (default),\n *       - `Q` has a shape of `[..., M, M]`,\n *       - `R` has a shape of `[..., M, N]`.\n *   If `M < N`,\n *     - `Q` has a shape of `[..., M, M]`,\n *     - `R` has a shape of `[..., M, N]`.\n * @throws If the rank of `x` is less than 2.\n */\n/**\n * @doc {heading:'Operations',\n *       subheading:'Linear Algebra',\n *       namespace:'linalg'}\n */\nfunction qr_(x: Tensor, fullMatrices = false): [Tensor, Tensor] {\n  if (x.rank < 2) {\n    throw new Error(\n        `qr() requires input tensor to have a rank >= 2, but got rank ${\n            x.rank}`);\n  } else if (x.rank === 2) {\n    return qr2d(x as Tensor2D, fullMatrices);\n  } else {\n    // Rank > 2.\n    // TODO(cais): Below we split the input into individual 2D tensors,\n    //   perform QR decomposition on them and then stack the results back\n    //   together. We should explore whether this can be parallelized.\n    const outerDimsProd = x.shape.slice(0, x.shape.length - 2)\n                              .reduce((value, prev) => value * prev);\n    const x2ds = unstack(\n        x.reshape([\n          outerDimsProd, x.shape[x.shape.length - 2],\n          x.shape[x.shape.length - 1]\n        ]),\n        0);\n    const q2ds: Tensor2D[] = [];\n    const r2ds: Tensor2D[] = [];\n    x2ds.forEach(x2d => {\n      const [q2d, r2d] = qr2d(x2d as Tensor2D, fullMatrices);\n      q2ds.push(q2d);\n      r2ds.push(r2d);\n    });\n    const q = stack(q2ds, 0).reshape(x.shape);\n    const r = stack(r2ds, 0).reshape(x.shape);\n    return [q, r];\n  }\n}\n\nfunction qr2d(x: Tensor2D, fullMatrices = false): [Tensor2D, Tensor2D] {\n  return ENGINE.tidy(() => {\n    if (x.shape.length !== 2) {\n      throw new Error(\n          `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);\n    }\n\n    const m = x.shape[0];\n    const n = x.shape[1];\n\n    let q = eye(m);     // Orthogonal transform so far.\n    let r = x.clone();  // Transformed matrix so far.\n\n    const one2D = tensor2d([[1]], [1, 1]);\n    let w: Tensor2D = one2D.clone();\n\n    const iters = m >= n ? n : m;\n    for (let j = 0; j < iters; ++j) {\n      // This tidy within the for-loop ensures we clean up temporary\n      // tensors as soon as they are no longer needed.\n      const rTemp = r;\n      const wTemp = w;\n      const qTemp = q;\n      [w, r, q] = ENGINE.tidy((): [Tensor2D, Tensor2D, Tensor2D] => {\n        // Find H = I - tau * w * w', to put zeros below R(j, j).\n        const rjEnd1 = r.slice([j, j], [m - j, 1]);\n        const normX = rjEnd1.norm();\n        const rjj = r.slice([j, j], [1, 1]);\n\n        // The sign() function returns 0 on 0, which causes division by zero.\n        const s = tensor2d([[-1]]).where(rjj.greater(0), tensor2d([[1]]));\n\n        const u1 = rjj.sub(s.mul(normX));\n        const wPre = rjEnd1.div(u1);\n        if (wPre.shape[0] === 1) {\n          w = one2D.clone();\n        } else {\n          w = one2D.concat(\n              wPre.slice([1, 0], [wPre.shape[0] - 1, wPre.shape[1]]) as\n                  Tensor2D,\n              0);\n        }\n        const tau = s.matMul(u1).div(normX).neg() as Tensor2D;\n\n        // -- R := HR, Q := QH.\n        const rjEndAll = r.slice([j, 0], [m - j, n]);\n        const tauTimesW: Tensor2D = tau.mul(w);\n        if (j === 0) {\n          r = rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll)));\n        } else {\n          const rTimesTau: Tensor2D =\n              rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll)));\n          r = r.slice([0, 0], [j, n]).concat(rTimesTau, 0);\n        }\n        const qAllJEnd = q.slice([0, j], [m, q.shape[1] - j]);\n        if (j === 0) {\n          q = qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose()));\n        } else {\n          const qTimesTau: Tensor2D =\n              qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose()));\n          q = q.slice([0, 0], [m, j]).concat(qTimesTau, 1);\n        }\n        return [w, r, q];\n      });\n      dispose([rTemp, wTemp, qTemp]);\n    }\n\n    if (!fullMatrices && m > n) {\n      q = q.slice([0, 0], [m, n]);\n      r = r.slice([0, 0], [n, n]);\n    }\n\n    return [q, r];\n  }) as [Tensor2D, Tensor2D];\n}\n\nexport const gramSchmidt = op({gramSchmidt_});\nexport const qr = op({qr_});\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {nonMaxSuppressionImpl} from '../backends/non_max_suppression_impl';\nimport {ENGINE, ForwardFunc} from '../engine';\nimport {Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Bilinear resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction resizeBilinear_<T extends Tensor3D|Tensor4D>(\n    images: T|TensorLike, size: [number, number], alignCorners = false): T {\n  const $images = convertToTensor(images, 'images', 'resizeBilinear');\n  util.assert(\n      $images.rank === 3 || $images.rank === 4,\n      () => `Error in resizeBilinear: x must be rank 3 or 4, but got ` +\n          `rank ${$images.rank}.`);\n  util.assert(\n      size.length === 2,\n      () => `Error in resizeBilinear: new shape must 2D, but got shape ` +\n          `${size}.`);\n\n  let batchImages = $images as Tensor4D;\n  let reshapedTo4D = false;\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages =\n        $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);\n  }\n\n  const [newHeight, newWidth] = size;\n  const forward: ForwardFunc<Tensor4D> = (backend, save) => {\n    save([batchImages]);\n    return backend.resizeBilinear(\n        batchImages, newHeight, newWidth, alignCorners);\n  };\n\n  const backward = (dy: Tensor4D, saved: Tensor[]) => {\n    return {\n      batchImages: () => ENGINE.runKernel(\n          backend => backend.resizeBilinearBackprop(\n              dy, saved[0] as Tensor4D, alignCorners),\n          {})\n    };\n  };\n\n  const res = ENGINE.runKernel(forward, {batchImages}, backward);\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * NearestNeighbor resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction resizeNearestNeighbor_<T extends Tensor3D|Tensor4D>(\n    images: T|TensorLike, size: [number, number], alignCorners = false): T {\n  const $images = convertToTensor(images, 'images', 'resizeNearestNeighbor');\n  util.assert(\n      $images.rank === 3 || $images.rank === 4,\n      () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` +\n          `rank ${$images.rank}.`);\n  util.assert(\n      size.length === 2,\n      () =>\n          `Error in resizeNearestNeighbor: new shape must 2D, but got shape ` +\n          `${size}.`);\n  util.assert(\n      $images.dtype === 'float32' || $images.dtype === 'int32',\n      () => '`images` must have `int32` or `float32` as dtype');\n\n  let batchImages = $images as Tensor4D;\n  let reshapedTo4D = false;\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages =\n        $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);\n  }\n  const [newHeight, newWidth] = size;\n\n  const forward: ForwardFunc<Tensor4D> = (backend, save) => {\n    save([batchImages]);\n    return backend.resizeNearestNeighbor(\n        batchImages, newHeight, newWidth, alignCorners);\n  };\n\n  const backward = (dy: Tensor4D, saved: Tensor[]) => {\n    return {\n      batchImages: () => ENGINE.runKernel(\n          backend => backend.resizeNearestNeighborBackprop(\n              dy, saved[0] as Tensor4D, alignCorners),\n          {})\n    };\n  };\n\n  const res = ENGINE.runKernel(forward, {batchImages}, backward);\n\n  if (reshapedTo4D) {\n    return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n  }\n  return res as T;\n}\n\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union)\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @return A 1D tensor with the selected box indices.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction nonMaxSuppression_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY): Tensor1D {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n\n  const inputs = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n\n  return ENGINE.runKernel(\n      b => b.nonMaxSuppression(\n          $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold),\n      {$boxes});\n}\n\n/** This is the async version of `nonMaxSuppression` */\nasync function nonMaxSuppressionAsync_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY): Promise<Tensor1D> {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n\n  const inputs = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n\n  const [boxesVals, scoresVals] =\n      await Promise.all([$boxes.data(), $scores.data()]);\n  const res = nonMaxSuppressionImpl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n  return res;\n}\n\nfunction nonMaxSuppSanityCheck(\n    boxes: Tensor2D, scores: Tensor1D, maxOutputSize: number,\n    iouThreshold: number, scoreThreshold: number):\n    {maxOutputSize: number, iouThreshold: number, scoreThreshold: number} {\n  if (iouThreshold == null) {\n    iouThreshold = 0.5;\n  }\n  if (scoreThreshold == null) {\n    scoreThreshold = Number.NEGATIVE_INFINITY;\n  }\n  const numBoxes = boxes.shape[0];\n  maxOutputSize = Math.min(maxOutputSize, numBoxes);\n\n  util.assert(\n      0 <= iouThreshold && iouThreshold <= 1,\n      () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);\n  util.assert(\n      boxes.rank === 2,\n      () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);\n  util.assert(\n      boxes.shape[1] === 4,\n      () =>\n          `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);\n  util.assert(scores.rank === 1, () => 'scores must be a 1D tensor');\n  util.assert(\n      scores.shape[0] === numBoxes,\n      () => `scores has incompatible shape with boxes. Expected ${numBoxes}, ` +\n          `but was ${scores.shape[0]}`);\n  return {maxOutputSize, iouThreshold, scoreThreshold};\n}\n\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by crop_size.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction cropAndResize_(\n    image: Tensor4D|TensorLike,\n    boxes: Tensor2D|TensorLike,\n    boxInd: Tensor1D|TensorLike,\n    cropSize: [number, number],\n    method?: 'bilinear'|'nearest',\n    extrapolationValue?: number,\n    ): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'cropAndResize', 'float32');\n  const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n  method = method || 'bilinear';\n  extrapolationValue = extrapolationValue || 0;\n\n  const numBoxes = $boxes.shape[0];\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in cropAndResize: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n  util.assert(\n      $boxes.rank === 2 && $boxes.shape[1] === 4,\n      () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +\n          `but had shape ${$boxes.shape}.`);\n  util.assert(\n      $boxInd.rank === 1 && $boxInd.shape[0] === numBoxes,\n      () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +\n          `but had shape ${$boxes.shape}.`);\n  util.assert(\n      cropSize.length === 2,\n      () => `Error in cropAndResize: cropSize must be of length 2, but got ` +\n          `length ${cropSize.length}.`);\n  util.assert(\n      cropSize[0] >= 1 && cropSize[1] >= 1,\n      () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n  util.assert(\n      method === 'bilinear' || method === 'nearest',\n      () => `method must be bilinear or nearest, but was ${method}`);\n\n  const forward: ForwardFunc<Tensor4D> = (backend, save) =>\n      backend.cropAndResize(\n          $image, $boxes, $boxInd, cropSize, method, extrapolationValue);\n\n  const res = ENGINE.runKernel(forward, {$image, $boxes});\n  return res;\n}\n\nexport const resizeBilinear = op({resizeBilinear_});\nexport const resizeNearestNeighbor = op({resizeNearestNeighbor_});\nexport const nonMaxSuppression = op({nonMaxSuppression_});\nexport const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;\nexport const cropAndResize = op({cropAndResize_});\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {conv2dDerFilter, conv2dDerInput} from '../ops/conv';\nimport * as conv_util from '../ops/conv_util';\nimport {op} from '../ops/operation';\nimport {Tensor, Tensor3D, Tensor4D} from '../tensor';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport * as broadcast_util from './broadcast_util';\nimport {Activation} from './fused_util';\n\n/**\n * Computes the dot product of two matrices with optional activation and bias.\n *\n * ```js\n * const a = tf.tensor2d([-1, -2], [1, 2]);\n * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const bias = tf.tensor2d([1, 2], [1, 2]);\n *\n * tf.fused.matMul({a, b, bias, activation: 'relu'}).print();\n * ```\n *\n * @param obj An object with the following properties:\n * - `a` First matrix in dot product operation.\n * - `b` Second matrix in dot product operation.\n * - `transposeA` If true, `a` is transposed before multiplication.\n * - `transposeB` If true, `b` is transposed before multiplication.\n * - `bias` Matrix to be added to the result.\n * - `activation` Name of activation kernel (defaults to `linear`).\n * - `preluActivationWeights` Tensor of prelu weights.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices', namespace: 'fused'} */\nfunction matMul_<T extends Tensor>({\n  a,\n  b,\n  transposeA = false,\n  transposeB = false,\n  bias,\n  activation = 'linear',\n  preluActivationWeights\n}: {\n  a: T|TensorLike,\n  b: T|TensorLike,\n  transposeA?: boolean,\n  transposeB?: boolean,\n  bias?: Tensor|TensorLike,\n  activation?: Activation,\n  preluActivationWeights?: Tensor\n}): T {\n  let $a = convertToTensor(a, 'a', 'fused matMul');\n  let $b = convertToTensor(b, 'b', 'fused matMul');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const innerShapeA =\n      transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];\n  const innerShapeB =\n      transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];\n\n  const outerShapeA =\n      transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];\n  const outerShapeB =\n      transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];\n\n  const outerDimsA = $a.shape.slice(0, -2);\n  const outerDimsB = $b.shape.slice(0, -2);\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  util.assert(\n      $a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank,\n      () =>\n          `Error in fused matMul: inputs must have the same rank of at least ` +\n          `2, got ranks ${$a.rank} and ${$b.rank}.`);\n\n  util.assert(\n      util.arraysEqual(outerDimsA, outerDimsB),\n      () => `Error in fused matMul: outer dimensions (${outerDimsA}) and (` +\n          `${outerDimsB}) of Tensors with shapes ${$a.shape} and ` +\n          `${$b.shape} must match.`);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in fused matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${$a.shape} and ` +\n          `${$b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);\n\n  const a3D = transposeA ? $a.as3D(batchDimA, innerShapeA, outerShapeA) :\n                           $a.as3D(batchDimA, outerShapeA, innerShapeA);\n  const b3D = transposeB ? $b.as3D(batchDimB, outerShapeB, innerShapeB) :\n                           $b.as3D(batchDimB, innerShapeB, outerShapeB);\n\n  let $bias: Tensor;\n  if (bias != null) {\n    $bias = convertToTensor(bias, 'bias', 'fused matMul');\n    [$bias] = makeTypesMatch($bias, $a);\n\n    broadcast_util.assertAndGetBroadcastShape(outShape, $bias.shape);\n  }\n\n  let $preluActivationWeights: Tensor;\n  if (preluActivationWeights != null) {\n    $preluActivationWeights = convertToTensor(\n        preluActivationWeights, 'prelu weights', 'fused matMul');\n  }\n\n  const grad = (dy: Tensor3D, saved: Tensor[]) => {\n    const [a3D, b3D, y] = saved;\n\n    let dyActivation: Tensor3D;\n    if (activation == null || activation === 'linear') {\n      dyActivation = dy;\n    } else if (activation === 'relu') {\n      dyActivation = dy.mul(y.step());\n    } else {\n      throw new Error(\n          `Gradient for activation ${activation} has not been ` +\n          `implemented yet.`);\n    }\n\n    let biasGradient = {};\n    if (bias != null) {\n      biasGradient = {\n        $bias: () => {\n          let res = dyActivation;\n          // Using dyActivation as reference shape because outputShape does not\n          // account for the fact that we temporarily reshape inputs to 3D as\n          // part of batched matMul.\n          const reduceAxes =\n              broadcast_util.getReductionAxes($bias.shape, dyActivation.shape);\n          if (reduceAxes.length > 0) {\n            res = res.sum(reduceAxes);\n          }\n          return res.reshape($bias.shape);\n        }\n      };\n    }\n\n    if (!transposeA && !transposeB) {\n      return Object.assign(\n          {\n            $a: () => dyActivation.matMul(b3D as Tensor3D, false, true),\n            $b: () => a3D.matMul(dyActivation, true, false)\n          },\n          biasGradient);\n    } else if (!transposeA && transposeB) {\n      return Object.assign(\n          {\n            $a: () => dyActivation.matMul(b3D as Tensor3D, false, false),\n            $b: () => dyActivation.matMul(a3D as Tensor3D, true, false)\n          },\n          biasGradient);\n    } else if (transposeA && !transposeB) {\n      return Object.assign(\n          {\n            $a: () => b3D.matMul(dyActivation, false, true),\n            $b: () => a3D.matMul(dyActivation, false, false)\n          },\n          biasGradient);\n    } else {\n      return Object.assign(\n          {\n            $a: () => b3D.matMul(dyActivation, true, true),\n            $b: () => dyActivation.matMul(a3D as Tensor3D, true, true)\n          },\n          biasGradient);\n    }\n  };\n\n  const inputs: {\n    $a: Tensor,\n    $b: Tensor,\n    $bias?: Tensor,\n    $preluActivationWeights?: Tensor\n  } = {$a: a3D, $b: b3D};\n  if (bias != null) {\n    inputs.$bias = $bias;\n  }\n  if (preluActivationWeights != null) {\n    inputs.$preluActivationWeights = $preluActivationWeights;\n  }\n\n  const res = ENGINE.runKernel((backend, save) => {\n    const y = backend.fusedBatchMatMul({\n      a: a3D,\n      b: b3D,\n      transposeA,\n      transposeB,\n      bias: $bias,\n      activation,\n      preluActivationWeights: $preluActivationWeights\n    });\n    save([a3D, b3D, y]);\n    return y;\n  }, inputs, grad);\n  return res.reshape(outShape) as T;\n}\n\n/**\n * Computes a 2D convolution over the input x, optionally fused with adding a\n * bias and applying an activation.\n *\n * ```js\n * const inputDepth = 2;\n * const inShape = [2, 2, 2, inputDepth];\n * const outputDepth = 2;\n * const fSize = 1;\n * const pad = 0;\n * const strides = 1;\n *\n * const x = tf.tensor4d( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n * 16], inShape);\n * const w = tf.tensor4d([-1, 1, -2, 0.5], [fSize, fSize, inputDepth,\n * outputDepth]);\n *\n * tf.fused.conv2d({ x, filter: w, strides, pad, dataFormat: 'NHWC',\n * dilations: [1, 1], bias: tf.scalar(5), activation: 'relu' }).print();\n * ```\n *\n * @param obj An object with the following properties:\n * - `x` The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * - `filter` The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n * - `strides` The strides of the convolution: `[strideHeight,\n * strideWidth]`.\n * - `pad` The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * - `dataFormat` An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n * - `dilations` The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * - `dimRoundingMode` The rounding mode used when computing output\n *     dimensions if pad is a number. If none is provided, it will not round\n *     and error if the output is of fractional size.\n * - `bias` Tensor to be added to the result.\n * - `activation` Name of activation kernel (defaults to `linear`) to be applied\n *      after biasAdd.\n * - `preluActivationWeights` Tensor of prelu weights to be applied as part of a\n *     `prelu` activation, typically the same shape as `x`.\n */\n/** @doc {heading: 'Operations', subheading: 'Convolution'} */\nfunction conv2d_<T extends Tensor3D|Tensor4D>({\n  x,\n  filter,\n  strides,\n  pad,\n  dataFormat = 'NHWC',\n  dilations = [1, 1],\n  dimRoundingMode,\n  bias,\n  activation = 'linear',\n  preluActivationWeights\n}: {\n  x: T|TensorLike,\n  filter: Tensor4D|TensorLike,\n  strides: [number, number]|number,\n  pad: 'valid'|'same'|number,\n  dataFormat?: 'NHWC'|'NCHW',\n  dilations?: [number, number]|number,\n  dimRoundingMode?: 'floor'|'round'|'ceil',\n  bias?: Tensor|TensorLike,\n  activation?: Activation,\n  preluActivationWeights?: Tensor\n}): T {\n  const $x = convertToTensor(x, 'x', 'conv2d');\n  const $filter = convertToTensor(filter, 'filter', 'conv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in fused conv2d: input must be rank 4, but got rank ` +\n          `${x4D.rank}.`);\n  util.assert(\n      $filter.rank === 4,\n      () => `Error in fused conv2d: filter must be rank 4, but got rank ` +\n          `${$filter.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in fused conv2d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  "\n      const ivec3 pads = ivec3("+f+", "+d+", "+v+");\n      const float avgMultiplier = float("+m+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+l+";\n            wD += "+s+") {\n          float dyD = float(dyDCorner + wD) / "+o+".0;\n\n          if (dyD < 0.0 || dyD >= "+t.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+h+";\n              wR += "+u+") {\n            float dyR = float(dyRCorner + wR) / "+i+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+p+";\n                wC += "+c+") {\n              float dyC = float(dyCCorner + wC) / "+a+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},$o=function(t,e,n,r,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],ro(t,e),ro(t,n);var a="0.0";null!=r&&(ro(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");var s="1.0";null!=o&&(ro(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+a+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+i+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "},Ko=function(t,e,n,r,o,i){this.usesPackedTextures=!0,this.variableNames=["x","mean","variance"],ro(t,e),ro(t,n);var a="vec4(0.0)";null!=r&&(ro(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");var s="vec4(1.0)";null!=o&&(ro(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = "+a+";\n        vec4 scale = "+s+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+i+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "},Xo=function(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ro(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+t+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "},Yo="return a + b;",Jo="return a - b;",Qo="return a * b;",Zo="return (a < 0.) ? b * a : a;",ti=function(t,e,n){this.variableNames=["A","B"],this.outputShape=ro(e,n),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+t+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "},ei="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ni=function(t,e,n,r){void 0===r&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.usesPackedTextures=!0,this.outputShape=ro(e,n);var o=this.outputShape.length,i="";if(r)if(0===o||1===L(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i="\n          "+Uo(o)+" coords = getOutputCoords();\n        ",1===o)i+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var a=Fo("coords",o);i+="\n            bool nextRowOutOfBounds =\n              ("+a[o-2]+" + 1) >= "+this.outputShape[o-2]+";\n            bool nextColOutOfBounds =\n              ("+a[o-1]+" + 1) >= "+this.outputShape[o-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+t+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+i+"\n\n        setOutput(result);\n      }\n    "},ri=(wi.prototype.getCustomSetupFunc=function(n,r){var o=this;return function(t,e){null==o.minLoc&&(o.minLoc=t.getUniformLocationNoThrow(e,"minVal"),o.maxLoc=t.getUniformLocationNoThrow(e,"maxVal")),t.gl.uniform1f(o.minLoc,n),t.gl.uniform1f(o.maxLoc,r)}},wi),oi=(bi.prototype.getCustomSetupFunc=function(n,r){var o=this;return function(t,e){null==o.minLoc&&(o.minLoc=t.getUniformLocationNoThrow(e,"minVal"),o.maxLoc=t.getUniformLocationNoThrow(e,"maxVal")),t.gl.uniform1f(o.minLoc,n),t.gl.uniform1f(o.maxLoc,r)}},bi),ii=function(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "},ai=function(t){this.outputShape=[],this.outputShape=mn(t,1),this.variableNames=t.map(function(t,e){return"T"+e});var e=new Array(t.length-1);e[0]=t[0][1];for(var n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];var r=["if (yC < "+e[0]+") setOutput(getT0(yR, yC));"];for(n=1;n<e.length;n++){var o=e[n-1];r.push("else if (yC < "+e[n]+") setOutput(getT"+n+"(yR, yC-"+o+"));")}var i=e.length,a=e[e.length-1];r.push("else setOutput(getT"+i+"(yR, yC-"+a+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+r.join("\n        ")+"\n      }\n    "},si=function(t,e){this.usesPackedTextures=!0,this.outputShape=[],this.outputShape=mn(t,e);var n=this.outputShape,r=n.length,o=Uo(r),i=Fo("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(function(t,e){return"T"+e});var s=new Array(t.length-1);s[0]=t[0][e];for(var u=1;u<s.length;u++)s[u]=s[u-1]+t[u][e];var c=a[e],l="vec2("+a.slice(-2).join()+")",h=a.join(),p="if ("+c+" < "+s[0]+")\n          return getChannel(getT0("+h+"), "+l+");";for(u=1;u<s.length;u++){var f=s[u-1];p+="\n        else if ("+c+" < "+s[u]+") {\n          "+c+" -= "+f+";\n          return getChannel(getT"+u+"("+h+"), "+l+");\n        }"}var d=s.length;p+="\n        else {\n          "+c+" -= "+s[s.length-1]+";\n          return getChannel(getT"+d+"("+h+"), "+l+");\n        }",this.userCode="\n      float getValue("+a.map(function(t){return"int "+t})+") {\n        "+p+"\n      }\n\n      void main() {\n        "+o+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+i+"), 0., 0., 0.);\n        if (++"+i[r-1]+" < "+n[r-1]+") {\n          result.g = getValue("+i+");\n        }\n        if (++"+i[r-2]+" < "+n[r-2]+") {\n          result.a = getValue("+i+");\n        }\n        if ("+i[r-2]+" < "+n[r-2]+" &&\n            --"+i[r-1]+" < "+n[r-1]+") {\n          result.b = getValue("+i+");\n        }\n        setOutput(result);\n      }\n    "},ui=function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,i="channelsLast"===t.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) t